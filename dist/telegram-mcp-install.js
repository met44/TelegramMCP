#!/usr/bin/env node
// =============================================================================
//  Telegram MCP Bridge â€” One-File Installer
//  Run: node install.js
//  Works on Windows, macOS, Linux. Requires Node.js 18+.
// =============================================================================

const readline = require("readline");
const https = require("https");
const fs = require("fs");
const path = require("path");
const os = require("os");
const { execSync } = require("child_process");

// ---------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------
const INSTALL_DIR = path.join(os.homedir(), ".telegram-mcp-bridge");
const IS_WIN = process.platform === "win32";
const IS_MAC = process.platform === "darwin";

// ---------------------------------------------------------------------------
// Colors (ANSI)
// ---------------------------------------------------------------------------
const C = {
  reset: "\x1b[0m", bold: "\x1b[1m", dim: "\x1b[2m",
  red: "\x1b[31m", green: "\x1b[32m", yellow: "\x1b[33m",
  blue: "\x1b[34m", cyan: "\x1b[36m",
};
const ok = (s) => console.log(`  ${C.green}âœ”${C.reset} ${s}`);
const warn = (s) => console.log(`  ${C.yellow}âš ${C.reset} ${s}`);
const fail = (s) => console.log(`  ${C.red}âœ˜${C.reset} ${s}`);
const info = (s) => console.log(`  ${C.dim}${s}${C.reset}`);
const step = (n, total, s) => console.log(`\n${C.blue}${C.bold}[${n}/${total}]${C.reset} ${C.bold}${s}${C.reset}`);

// ---------------------------------------------------------------------------
// Readline helper
// ---------------------------------------------------------------------------
const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
const ask = (q) => new Promise((res) => rl.question(`  ${C.cyan}â–¸${C.reset} ${q}`, res));

// ---------------------------------------------------------------------------
// HTTP helpers
// ---------------------------------------------------------------------------
function httpGet(url) {
  return new Promise((resolve, reject) => {
    https.get(url, { timeout: 15000 }, (res) => {
      let data = "";
      res.on("data", (c) => (data += c));
      res.on("end", () => resolve(data));
    }).on("error", reject).on("timeout", function () { this.destroy(); reject(new Error("timeout")); });
  });
}

function httpPost(url, body) {
  return new Promise((resolve, reject) => {
    const payload = JSON.stringify(body);
    const u = new URL(url);
    const opts = {
      hostname: u.hostname, path: u.pathname, method: "POST", timeout: 15000,
      headers: { "Content-Type": "application/json", "Content-Length": Buffer.byteLength(payload) },
    };
    const req = https.request(opts, (res) => {
      let data = "";
      res.on("data", (c) => (data += c));
      res.on("end", () => resolve(data));
    });
    req.on("error", reject);
    req.on("timeout", () => { req.destroy(); reject(new Error("timeout")); });
    req.write(payload);
    req.end();
  });
}

function tgApi(token, method, body) {
  const url = `https://api.telegram.org/bot${token}/${method}`;
  return body ? httpPost(url, body).then(JSON.parse) : httpGet(url).then(JSON.parse);
}

// ---------------------------------------------------------------------------
// Open URL cross-platform
// ---------------------------------------------------------------------------
function openUrl(url) {
  try {
    if (IS_WIN) execSync(`start "" "${url}"`, { stdio: "ignore", shell: true });
    else if (IS_MAC) execSync(`open "${url}"`, { stdio: "ignore" });
    else execSync(`xdg-open "${url}" 2>/dev/null || sensible-browser "${url}" 2>/dev/null`, { stdio: "ignore", shell: true });
  } catch { /* ignore */ }
}

// ---------------------------------------------------------------------------
// Agent definitions
// ---------------------------------------------------------------------------
const AGENTS = [
  { id: 1, name: "Claude Code", configPath: () => path.join(os.homedir(), ".claude.json"), key: "mcpServers" },
  {
    id: 2, name: "Claude Desktop", key: "mcpServers",
    configPath: () => {
      if (IS_WIN) return path.join(process.env.APPDATA || path.join(os.homedir(), "AppData", "Roaming"), "Claude", "claude_desktop_config.json");
      if (IS_MAC) return path.join(os.homedir(), "Library", "Application Support", "Claude", "claude_desktop_config.json");
      return path.join(os.homedir(), ".config", "Claude", "claude_desktop_config.json");
    },
  },
  { id: 3, name: "Cursor", configPath: () => path.join(os.homedir(), ".cursor", "mcp.json"), key: "mcpServers" },
  { id: 4, name: "Windsurf", configPath: () => path.join(os.homedir(), ".codeium", "windsurf", "mcp_config.json"), key: "mcpServers" },
  {
    id: 5, name: "VS Code (Copilot)", configPath: () => "__vscode__", key: "servers",
  },
  { id: 6, name: "Gemini CLI", configPath: () => path.join(os.homedir(), ".gemini", "settings.json"), key: "mcpServers" },
  { id: 7, name: "Cline", configPath: () => path.join(os.homedir(), ".cline", "mcp_config.json"), key: "mcpServers" },
  { id: 8, name: "Other / Manual", configPath: () => "__manual__", key: "mcpServers" },
];

// ---------------------------------------------------------------------------
// Server entry JSON for config injection
// ---------------------------------------------------------------------------
function makeServerEntry(serverPath, botToken, chatId) {
  // Normalize to forward slashes for JSON config (Node handles both on Windows)
  const normalizedPath = serverPath.replace(/\\/g, "/");
  return {
    command: "node",
    args: [normalizedPath],
    env: {
      TELEGRAM_BOT_TOKEN: botToken,
      TELEGRAM_CHAT_ID: chatId,
    },
  };
}

// ---------------------------------------------------------------------------
// Config injection
// ---------------------------------------------------------------------------
function injectConfig(configPath, key, entry) {
  let config = {};
  if (fs.existsSync(configPath)) {
    try {
      config = JSON.parse(fs.readFileSync(configPath, "utf-8"));
    } catch {
      config = {};
    }
    // Backup
    const bak = configPath + ".bak." + Date.now();
    fs.copyFileSync(configPath, bak);
    info(`Backed up to ${path.basename(bak)}`);
  }
  fs.mkdirSync(path.dirname(configPath), { recursive: true });
  if (!config[key]) config[key] = {};
  config[key]["telegram-bridge"] = entry;
  fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
}

// ---------------------------------------------------------------------------
// Embedded server.js as base64 (injected by build.js, or read from adjacent file)
// ---------------------------------------------------------------------------
const SERVER_B64 = "IyEvdXNyL2Jpbi9lbnYgbm9kZQ0KLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0NCi8vICBUZWxlZ3JhbSBNQ1AgQnJpZGdlIFNlcnZlciB2Mg0KLy8gIEJyaWRnZXMgQUkgYWdlbnQgc2Vzc2lvbnMgd2l0aCBhIGh1bWFuIHZpYSBUZWxlZ3JhbSBGb3J1bSBUb3BpY3MuDQovLyAgRWFjaCBzZXNzaW9uIGdldHMgaXRzIG93biB0b3BpYyDigJQgZnVsbCBwZXItYWdlbnQgaXNvbGF0aW9uLg0KLy8gIFNpbmdsZSB1bmlmaWVkIHRvb2w6IGludGVyYWN0DQovLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQ0KDQpjb25zdCB7IFNlcnZlciB9ID0gcmVxdWlyZSgiQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zZXJ2ZXIvaW5kZXguanMiKTsNCmNvbnN0IHsgU3RkaW9TZXJ2ZXJUcmFuc3BvcnQgfSA9IHJlcXVpcmUoIkBtb2RlbGNvbnRleHRwcm90b2NvbC9zZGsvc2VydmVyL3N0ZGlvLmpzIik7DQpjb25zdCB7DQogIENhbGxUb29sUmVxdWVzdFNjaGVtYSwNCiAgTGlzdFRvb2xzUmVxdWVzdFNjaGVtYSwNCn0gPSByZXF1aXJlKCJAbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3R5cGVzLmpzIik7DQpjb25zdCBodHRwcyA9IHJlcXVpcmUoImh0dHBzIik7DQpjb25zdCBmcyA9IHJlcXVpcmUoImZzIik7DQpjb25zdCBwYXRoID0gcmVxdWlyZSgicGF0aCIpOw0KY29uc3Qgb3MgPSByZXF1aXJlKCJvcyIpOw0KY29uc3QgY3J5cHRvID0gcmVxdWlyZSgiY3J5cHRvIik7DQoNCi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KLy8gQ29uZmlnIGZyb20gZW52DQovLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCmNvbnN0IEJPVF9UT0tFTiA9IHByb2Nlc3MuZW52LlRFTEVHUkFNX0JPVF9UT0tFTiB8fCAiIjsNCmxldCBDSEFUX0lEID0gcHJvY2Vzcy5lbnYuVEVMRUdSQU1fQ0hBVF9JRCB8fCAiIjsNCmNvbnN0IERBVEFfRElSID0gcHJvY2Vzcy5lbnYuVEVMRUdSQU1fTUNQX0RBVEFfRElSIHx8DQogIHBhdGguam9pbihvcy5ob21lZGlyKCksICIudGVsZWdyYW0tbWNwLWJyaWRnZSIsICJkYXRhIik7DQpjb25zdCBNQVhfSElTVE9SWSA9IHBhcnNlSW50KHByb2Nlc3MuZW52LlRFTEVHUkFNX01DUF9NQVhfSElTVE9SWSB8fCAiMjAwIiwgMTApOw0KY29uc3QgUE9MTF9JTlRFUlZBTF9NUyA9IHBhcnNlSW50KHByb2Nlc3MuZW52LlRFTEVHUkFNX1BPTExfSU5URVJWQUwgfHwgIjIwMDAiLCAxMCk7DQoNCi8vIFNlc3Npb24gaWRlbnRpdHkg4oCUIGVhY2ggTUNQIHNlcnZlciBpbnN0YW5jZSBpcyBvbmUgc2Vzc2lvbg0KY29uc3QgU0VTU0lPTl9JRCA9IHByb2Nlc3MuZW52LlRFTEVHUkFNX1NFU1NJT05fSUQgfHwNCiAgYHMtJHtjcnlwdG8ucmFuZG9tQnl0ZXMoMykudG9TdHJpbmcoImhleCIpfWA7DQpjb25zdCBNQUNISU5FX0xBQkVMID0gcHJvY2Vzcy5lbnYuVEVMRUdSQU1fTUFDSElORV9MQUJFTCB8fA0KICBvcy5ob3N0bmFtZSgpLnNsaWNlKDAsIDIwKTsNCmNvbnN0IEFHRU5UX0xBQkVMID0gcHJvY2Vzcy5lbnYuVEVMRUdSQU1fQUdFTlRfTEFCRUwgfHwgImFnZW50IjsNCmNvbnN0IFNFU1NJT05fTEFCRUwgPSBgJHtNQUNISU5FX0xBQkVMfS8ke0FHRU5UX0xBQkVMfWA7DQoNCi8vIEJlaGF2aW9yIGZsYWdzIChzZXQgaW4gTUNQIGNvbmZpZyBlbnYgYmxvY2spDQpjb25zdCBBVVRPX1NFTkRfU1RBUlQgPSBwcm9jZXNzLmVudi5URUxFR1JBTV9BVVRPX1NUQVJUICE9PSAiZmFsc2UiOw0KY29uc3QgQVVUT19TRU5EX0VORCA9IHByb2Nlc3MuZW52LlRFTEVHUkFNX0FVVE9fRU5EICE9PSAiZmFsc2UiOw0KY29uc3QgQVVUT19TVU1NQVJZID0gcHJvY2Vzcy5lbnYuVEVMRUdSQU1fQVVUT19TVU1NQVJZICE9PSAiZmFsc2UiOw0KY29uc3QgQVVUT19QT0xMID0gcHJvY2Vzcy5lbnYuVEVMRUdSQU1fQVVUT19QT0xMICE9PSAiZmFsc2UiOw0KDQovLyBMZWdhY3kgY29tcGF0OiBvbGQgUVVFVUVfRklMRSBlbnYgc3RpbGwgd29ya3MgZm9yIHNpbmdsZS1zZXNzaW9uIHNldHVwcw0KY29uc3QgTEVHQUNZX1FVRVVFX0ZJTEUgPSBwcm9jZXNzLmVudi5URUxFR1JBTV9NQ1BfUVVFVUVfRklMRSB8fCAiIjsNCg0KLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQovLyBMb2dnaW5nIChzdGRlcnIgb25seSDigJQgc3Rkb3V0IGlzIE1DUCBzdGRpbyB0cmFuc3BvcnQpDQovLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCmNvbnN0IGxvZyA9IHsNCiAgaW5mbzogKC4uLmEpID0+IHByb2Nlc3Muc3RkZXJyLndyaXRlKGBbSU5GT10gJHthLmpvaW4oIiAiKX1cbmApLA0KICB3YXJuOiAoLi4uYSkgPT4gcHJvY2Vzcy5zdGRlcnIud3JpdGUoYFtXQVJOXSAke2Euam9pbigiICIpfVxuYCksDQogIGVycm9yOiAoLi4uYSkgPT4gcHJvY2Vzcy5zdGRlcnIud3JpdGUoYFtFUlJPUl0gJHthLmpvaW4oIiAiKX1cbmApLA0KfTsNCg0KLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQovLyBUZWxlZ3JhbSBIVFRQIGhlbHBlcnMgKHplcm8gZGVwZW5kZW5jaWVzIOKAlCB1c2VzIGJ1aWx0LWluIGh0dHBzKQ0KLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQpmdW5jdGlvbiB0Z0FwaShtZXRob2QsIGJvZHkpIHsNCiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHsNCiAgICBjb25zdCBwYXlsb2FkID0gYm9keSA/IEpTT04uc3RyaW5naWZ5KGJvZHkpIDogbnVsbDsNCiAgICBjb25zdCBvcHRzID0gew0KICAgICAgaG9zdG5hbWU6ICJhcGkudGVsZWdyYW0ub3JnIiwNCiAgICAgIHBhdGg6IGAvYm90JHtCT1RfVE9LRU59LyR7bWV0aG9kfWAsDQogICAgICBtZXRob2Q6IHBheWxvYWQgPyAiUE9TVCIgOiAiR0VUIiwNCiAgICAgIGhlYWRlcnM6IHBheWxvYWQNCiAgICAgICAgPyB7ICJDb250ZW50LVR5cGUiOiAiYXBwbGljYXRpb24vanNvbiIsICJDb250ZW50LUxlbmd0aCI6IEJ1ZmZlci5ieXRlTGVuZ3RoKHBheWxvYWQpIH0NCiAgICAgICAgOiB7fSwNCiAgICAgIHRpbWVvdXQ6IDMwMDAwLA0KICAgIH07DQogICAgY29uc3QgcmVxID0gaHR0cHMucmVxdWVzdChvcHRzLCAocmVzKSA9PiB7DQogICAgICBsZXQgZGF0YSA9ICIiOw0KICAgICAgcmVzLm9uKCJkYXRhIiwgKGMpID0+IChkYXRhICs9IGMpKTsNCiAgICAgIHJlcy5vbigiZW5kIiwgKCkgPT4gew0KICAgICAgICB0cnkgew0KICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKGRhdGEpOw0KICAgICAgICAgIHJlc29sdmUoanNvbik7DQogICAgICAgIH0gY2F0Y2ggew0KICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEludmFsaWQgSlNPTiBmcm9tIFRlbGVncmFtOiAke2RhdGEuc2xpY2UoMCwgMjAwKX1gKSk7DQogICAgICAgIH0NCiAgICAgIH0pOw0KICAgIH0pOw0KICAgIHJlcS5vbigiZXJyb3IiLCByZWplY3QpOw0KICAgIHJlcS5vbigidGltZW91dCIsICgpID0+IHsgcmVxLmRlc3Ryb3koKTsgcmVqZWN0KG5ldyBFcnJvcigiVGVsZWdyYW0gQVBJIHRpbWVvdXQiKSk7IH0pOw0KICAgIGlmIChwYXlsb2FkKSByZXEud3JpdGUocGF5bG9hZCk7DQogICAgcmVxLmVuZCgpOw0KICB9KTsNCn0NCg0KLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQovLyBUb3BpYyBtYW5hZ2VtZW50IOKAlCBlYWNoIHNlc3Npb24gZ2V0cyBpdHMgb3duIGZvcnVtIHRvcGljDQovLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCmxldCB0b3BpY0lkID0gbnVsbDsgLy8gbWVzc2FnZV90aHJlYWRfaWQgZm9yIHRoaXMgc2Vzc2lvbidzIHRvcGljDQoNCi8vIFBlcnNpc3RlZCB0b3BpYyBtYXA6IHsgc2Vzc2lvbklkOiB0b3BpY0lkIH0NCmZ1bmN0aW9uIGdldFRvcGljTWFwRmlsZSgpIHsgcmV0dXJuIHBhdGguam9pbihEQVRBX0RJUiwgIl90b3BpY3MuanNvbiIpOyB9DQoNCmZ1bmN0aW9uIGxvYWRUb3BpY01hcCgpIHsNCiAgdHJ5IHsNCiAgICBpZiAoZnMuZXhpc3RzU3luYyhnZXRUb3BpY01hcEZpbGUoKSkpIHsNCiAgICAgIHJldHVybiBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhnZXRUb3BpY01hcEZpbGUoKSwgInV0Zi04IikpOw0KICAgIH0NCiAgfSBjYXRjaCB7IC8qIG9rICovIH0NCiAgcmV0dXJuIHt9Ow0KfQ0KDQpmdW5jdGlvbiBzYXZlVG9waWNNYXAobWFwKSB7DQogIHRyeSB7DQogICAgZnMubWtkaXJTeW5jKERBVEFfRElSLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTsNCiAgICBmcy53cml0ZUZpbGVTeW5jKGdldFRvcGljTWFwRmlsZSgpLCBKU09OLnN0cmluZ2lmeShtYXAsIG51bGwsIDIpKTsNCiAgfSBjYXRjaCAoZSkgew0KICAgIGxvZy53YXJuKCJUb3BpYyBtYXAgc2F2ZSBmYWlsZWQ6IiwgZS5tZXNzYWdlKTsNCiAgfQ0KfQ0KDQphc3luYyBmdW5jdGlvbiBlbnN1cmVUb3BpYygpIHsNCiAgaWYgKCFCT1RfVE9LRU4gfHwgIUNIQVRfSUQpIHJldHVybiBudWxsOw0KDQogIC8vIENoZWNrIGlmIHdlIGFscmVhZHkgaGF2ZSBhIHRvcGljIGZvciB0aGlzIHNlc3Npb24NCiAgY29uc3QgbWFwID0gbG9hZFRvcGljTWFwKCk7DQogIGlmIChtYXBbU0VTU0lPTl9JRF0pIHsNCiAgICB0b3BpY0lkID0gbWFwW1NFU1NJT05fSURdOw0KICAgIGxvZy5pbmZvKGBSZXVzaW5nIHRvcGljICR7dG9waWNJZH0gZm9yICR7U0VTU0lPTl9JRH0gKCR7U0VTU0lPTl9MQUJFTH0pYCk7DQogICAgcmV0dXJuIHRvcGljSWQ7DQogIH0NCg0KICAvLyBDcmVhdGUgYSBuZXcgdG9waWMNCiAgdHJ5IHsNCiAgICBsZXQgY2hhdElkTnVtID0gcGFyc2VJbnQoQ0hBVF9JRCwgMTApOw0KICAgIGxldCByZXMgPSBhd2FpdCB0Z0FwaSgiY3JlYXRlRm9ydW1Ub3BpYyIsIHsNCiAgICAgIGNoYXRfaWQ6IGNoYXRJZE51bSwNCiAgICAgIG5hbWU6IGDwn6SWICR7U0VTU0lPTl9MQUJFTH0gWyR7U0VTU0lPTl9JRH1dYCwNCiAgICB9KTsNCg0KICAgIC8vIEhhbmRsZSBjaGF0IG1pZ3JhdGlvbiAoZ3JvdXAgdXBncmFkZWQgdG8gc3VwZXJncm91cCkNCiAgICBpZiAoIXJlcy5vayAmJiByZXMucGFyYW1ldGVycz8ubWlncmF0ZV90b19jaGF0X2lkKSB7DQogICAgICBjb25zdCBuZXdJZCA9IFN0cmluZyhyZXMucGFyYW1ldGVycy5taWdyYXRlX3RvX2NoYXRfaWQpOw0KICAgICAgbG9nLmluZm8oYENoYXQgbWlncmF0ZWQ6ICR7Q0hBVF9JRH0g4oaSICR7bmV3SWR9YCk7DQogICAgICBDSEFUX0lEID0gbmV3SWQ7DQogICAgICBjaGF0SWROdW0gPSBwYXJzZUludChDSEFUX0lELCAxMCk7DQogICAgICByZXMgPSBhd2FpdCB0Z0FwaSgiY3JlYXRlRm9ydW1Ub3BpYyIsIHsNCiAgICAgICAgY2hhdF9pZDogY2hhdElkTnVtLA0KICAgICAgICBuYW1lOiBg8J+kliAke1NFU1NJT05fTEFCRUx9IFske1NFU1NJT05fSUR9XWAsDQogICAgICB9KTsNCiAgICB9DQoNCiAgICBpZiAocmVzLm9rICYmIHJlcy5yZXN1bHQpIHsNCiAgICAgIHRvcGljSWQgPSByZXMucmVzdWx0Lm1lc3NhZ2VfdGhyZWFkX2lkOw0KICAgICAgbWFwW1NFU1NJT05fSURdID0gdG9waWNJZDsNCiAgICAgIHNhdmVUb3BpY01hcChtYXApOw0KICAgICAgbG9nLmluZm8oYENyZWF0ZWQgdG9waWMgJHt0b3BpY0lkfSBmb3IgJHtTRVNTSU9OX0lEfSAoJHtTRVNTSU9OX0xBQkVMfSlgKTsNCiAgICAgIHJldHVybiB0b3BpY0lkOw0KICAgIH0NCiAgICBsb2cud2FybigiY3JlYXRlRm9ydW1Ub3BpYyBmYWlsZWQ6IiwgSlNPTi5zdHJpbmdpZnkocmVzKSk7DQogIH0gY2F0Y2ggKGUpIHsNCiAgICBsb2cud2FybigiY3JlYXRlRm9ydW1Ub3BpYyBlcnJvcjoiLCBlLm1lc3NhZ2UpOw0KICB9DQoNCiAgLy8gRmFsbGJhY2s6IG5vIHRvcGljIChzZW5kIHRvIEdlbmVyYWwpDQogIHJldHVybiBudWxsOw0KfQ0KDQovLyBCdWlsZCByZXZlcnNlIG1hcDogdG9waWNJZCDihpIgc2Vzc2lvbklkIChmb3Igcm91dGluZyBpbmNvbWluZyBtZXNzYWdlcykNCmZ1bmN0aW9uIGJ1aWxkVG9waWNUb1Nlc3Npb25NYXAoKSB7DQogIGNvbnN0IG1hcCA9IGxvYWRUb3BpY01hcCgpOw0KICBjb25zdCByZXZlcnNlID0ge307DQogIGZvciAoY29uc3QgW3NpZCwgdGlkXSBvZiBPYmplY3QuZW50cmllcyhtYXApKSB7DQogICAgcmV2ZXJzZVtTdHJpbmcodGlkKV0gPSBzaWQ7DQogIH0NCiAgcmV0dXJuIHJldmVyc2U7DQp9DQoNCi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KLy8gU2VuZCBtZXNzYWdlIHRvIHRoaXMgc2Vzc2lvbidzIHRvcGljIChvciBHZW5lcmFsIGFzIGZhbGxiYWNrKQ0KLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQphc3luYyBmdW5jdGlvbiBzZW5kVG9Ub3BpYyh0ZXh0KSB7DQogIGlmICghQk9UX1RPS0VOIHx8ICFDSEFUX0lEKSByZXR1cm4gZmFsc2U7DQogIGNvbnN0IGJvZHkgPSB7DQogICAgY2hhdF9pZDogcGFyc2VJbnQoQ0hBVF9JRCwgMTApLA0KICAgIHRleHQsDQogICAgcGFyc2VfbW9kZTogIk1hcmtkb3duIiwNCiAgfTsNCiAgaWYgKHRvcGljSWQpIGJvZHkubWVzc2FnZV90aHJlYWRfaWQgPSB0b3BpY0lkOw0KICB0cnkgew0KICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRnQXBpKCJzZW5kTWVzc2FnZSIsIGJvZHkpOw0KICAgIGlmIChyZXMub2spIHJldHVybiB0cnVlOw0KICAgIC8vIE1hcmtkb3duIHBhcnNlIGVycm9yIOKAlCByZXRyeSBwbGFpbg0KICAgIGRlbGV0ZSBib2R5LnBhcnNlX21vZGU7DQogICAgY29uc3QgcmVzMiA9IGF3YWl0IHRnQXBpKCJzZW5kTWVzc2FnZSIsIGJvZHkpOw0KICAgIHJldHVybiAhIXJlczIub2s7DQogIH0gY2F0Y2ggKGUpIHsNCiAgICBsb2cuZXJyb3IoInNlbmRNZXNzYWdlIGZhaWxlZDoiLCBlLm1lc3NhZ2UpOw0KICAgIHJldHVybiBmYWxzZTsNCiAgfQ0KfQ0KDQovLyBTZW5kIHRvIEdlbmVyYWwgdG9waWMgKG5vIG1lc3NhZ2VfdGhyZWFkX2lkKQ0KYXN5bmMgZnVuY3Rpb24gc2VuZFRvR2VuZXJhbCh0ZXh0KSB7DQogIGlmICghQk9UX1RPS0VOIHx8ICFDSEFUX0lEKSByZXR1cm4gZmFsc2U7DQogIHRyeSB7DQogICAgY29uc3QgcmVzID0gYXdhaXQgdGdBcGkoInNlbmRNZXNzYWdlIiwgew0KICAgICAgY2hhdF9pZDogcGFyc2VJbnQoQ0hBVF9JRCwgMTApLA0KICAgICAgdGV4dCwNCiAgICAgIHBhcnNlX21vZGU6ICJNYXJrZG93biIsDQogICAgfSk7DQogICAgaWYgKHJlcy5vaykgcmV0dXJuIHRydWU7DQogICAgY29uc3QgcmVzMiA9IGF3YWl0IHRnQXBpKCJzZW5kTWVzc2FnZSIsIHsNCiAgICAgIGNoYXRfaWQ6IHBhcnNlSW50KENIQVRfSUQsIDEwKSwNCiAgICAgIHRleHQsDQogICAgfSk7DQogICAgcmV0dXJuICEhcmVzMi5vazsNCiAgfSBjYXRjaCAoZSkgew0KICAgIGxvZy5lcnJvcigic2VuZFRvR2VuZXJhbCBmYWlsZWQ6IiwgZS5tZXNzYWdlKTsNCiAgICByZXR1cm4gZmFsc2U7DQogIH0NCn0NCg0KLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQovLyBNZXNzYWdlIHF1ZXVlIOKAlCBwZXJzaXN0ZWQgdG8gZGlzaywgbWluaW1hbCBtZW1vcnkgZm9vdHByaW50DQovLyBFYWNoIHNlc3Npb24gaGFzIGl0cyBvd24gcXVldWUuIE1lc3NhZ2VzIHJvdXRlZCBieSB0b3BpYy4NCi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KY2xhc3MgTWVzc2FnZVF1ZXVlIHsNCiAgY29uc3RydWN0b3IoZmlsZVBhdGgpIHsNCiAgICB0aGlzLl9maWxlID0gZmlsZVBhdGg7DQogICAgdGhpcy5fcGVuZGluZyA9IFtdOw0KICAgIHRoaXMuX2RlbGl2ZXJlZCA9IFtdOw0KICAgIHRoaXMuX2xvYWQoKTsNCiAgfQ0KDQogIF9sb2FkKCkgew0KICAgIHRyeSB7DQogICAgICBpZiAoZnMuZXhpc3RzU3luYyh0aGlzLl9maWxlKSkgew0KICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmModGhpcy5fZmlsZSwgInV0Zi04IikpOw0KICAgICAgICB0aGlzLl9wZW5kaW5nID0gZGF0YS5wZW5kaW5nIHx8IFtdOw0KICAgICAgICB0aGlzLl9kZWxpdmVyZWQgPSAoZGF0YS5kZWxpdmVyZWQgfHwgW10pLnNsaWNlKC1NQVhfSElTVE9SWSk7DQogICAgICB9DQogICAgfSBjYXRjaCAoZSkgew0KICAgICAgbG9nLndhcm4oIlF1ZXVlIGxvYWQgZmFpbGVkOiIsIGUubWVzc2FnZSk7DQogICAgfQ0KICB9DQoNCiAgX3NhdmUoKSB7DQogICAgdHJ5IHsNCiAgICAgIGZzLm1rZGlyU3luYyhwYXRoLmRpcm5hbWUodGhpcy5fZmlsZSksIHsgcmVjdXJzaXZlOiB0cnVlIH0pOw0KICAgICAgZnMud3JpdGVGaWxlU3luYyh0aGlzLl9maWxlLCBKU09OLnN0cmluZ2lmeSh7DQogICAgICAgIHBlbmRpbmc6IHRoaXMuX3BlbmRpbmcsDQogICAgICAgIGRlbGl2ZXJlZDogdGhpcy5fZGVsaXZlcmVkLnNsaWNlKC1NQVhfSElTVE9SWSksDQogICAgICB9LCBudWxsLCAyKSk7DQogICAgfSBjYXRjaCAoZSkgew0KICAgICAgbG9nLndhcm4oIlF1ZXVlIHNhdmUgZmFpbGVkOiIsIGUubWVzc2FnZSk7DQogICAgfQ0KICB9DQoNCiAgZW5xdWV1ZSh0ZXh0LCBzZW5kZXIgPSAidXNlciIpIHsNCiAgICBjb25zdCBtc2cgPSB7DQogICAgICBpZDogY3J5cHRvLnJhbmRvbUJ5dGVzKDQpLnRvU3RyaW5nKCJoZXgiKSwNCiAgICAgIHRleHQsDQogICAgICBzZW5kZXIsDQogICAgICB0czogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksDQogICAgfTsNCiAgICB0aGlzLl9wZW5kaW5nLnB1c2gobXNnKTsNCiAgICB0aGlzLl9zYXZlKCk7DQogICAgcmV0dXJuIG1zZzsNCiAgfQ0KDQogIHBvbGwoKSB7DQogICAgaWYgKCF0aGlzLl9wZW5kaW5nLmxlbmd0aCkgcmV0dXJuIFtdOw0KICAgIGNvbnN0IG1zZ3MgPSB0aGlzLl9wZW5kaW5nLnNwbGljZSgwKTsNCiAgICB0aGlzLl9kZWxpdmVyZWQucHVzaCguLi5tc2dzKTsNCiAgICB0aGlzLl9zYXZlKCk7DQogICAgcmV0dXJuIG1zZ3M7DQogIH0NCg0KICAvLyBQb2xsIG9ubHkgbWVzc2FnZXMgd2l0aCB0cyA+IHNpbmNlVHMgKGZvciB0aW1lc3RhbXAtYXdhcmUgcG9sbGluZykNCiAgcG9sbFNpbmNlKHNpbmNlVHMpIHsNCiAgICBpZiAoIXRoaXMuX3BlbmRpbmcubGVuZ3RoKSByZXR1cm4gW107DQogICAgY29uc3QgZnJlc2ggPSBbXTsNCiAgICBjb25zdCBzdGFsZSA9IFtdOw0KICAgIGZvciAoY29uc3QgbSBvZiB0aGlzLl9wZW5kaW5nKSB7DQogICAgICBpZiAobS50cyA+IHNpbmNlVHMpIGZyZXNoLnB1c2gobSk7DQogICAgICBlbHNlIHN0YWxlLnB1c2gobSk7DQogICAgfQ0KICAgIC8vIE1vdmUgc3RhbGUgdG8gZGVsaXZlcmVkIChhZ2VudCBhbHJlYWR5IHNhdyB0aGVtIGJlZm9yZSkNCiAgICBpZiAoc3RhbGUubGVuZ3RoKSB0aGlzLl9kZWxpdmVyZWQucHVzaCguLi5zdGFsZSk7DQogICAgLy8gTW92ZSBmcmVzaCB0byBkZWxpdmVyZWQgdG9vIChiZWluZyByZXR1cm5lZCBub3cpDQogICAgaWYgKGZyZXNoLmxlbmd0aCkgdGhpcy5fZGVsaXZlcmVkLnB1c2goLi4uZnJlc2gpOw0KICAgIHRoaXMuX3BlbmRpbmcgPSBbXTsNCiAgICB0aGlzLl9zYXZlKCk7DQogICAgcmV0dXJuIGZyZXNoOw0KICB9DQoNCiAgcGVuZGluZ0NvdW50KCkgew0KICAgIHJldHVybiB0aGlzLl9wZW5kaW5nLmxlbmd0aDsNCiAgfQ0KDQogIHBlbmRpbmdDb3VudFNpbmNlKHNpbmNlVHMpIHsNCiAgICBpZiAoIXNpbmNlVHMpIHJldHVybiB0aGlzLl9wZW5kaW5nLmxlbmd0aDsNCiAgICByZXR1cm4gdGhpcy5fcGVuZGluZy5maWx0ZXIoKG0pID0+IG0udHMgPiBzaW5jZVRzKS5sZW5ndGg7DQogIH0NCg0KICBjbGVhcigpIHsNCiAgICB0aGlzLl9wZW5kaW5nID0gW107DQogICAgdGhpcy5fZGVsaXZlcmVkID0gW107DQogICAgdGhpcy5fc2F2ZSgpOw0KICB9DQp9DQoNCi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KLy8gU2Vzc2lvbiByZWdpc3RyeSDigJQgdHJhY2tzIGFsbCBhY3RpdmUgc2Vzc2lvbnMgYWNyb3NzIG1hY2hpbmVzDQovLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCmNsYXNzIFNlc3Npb25SZWdpc3RyeSB7DQogIGNvbnN0cnVjdG9yKGRhdGFEaXIpIHsNCiAgICB0aGlzLl9kaXIgPSBkYXRhRGlyOw0KICAgIHRoaXMuX2ZpbGUgPSBwYXRoLmpvaW4oZGF0YURpciwgIl9zZXNzaW9ucy5qc29uIik7DQogICAgdGhpcy5fc2Vzc2lvbnMgPSB7fTsNCiAgICB0aGlzLl9sb2FkKCk7DQogIH0NCg0KICBfbG9hZCgpIHsNCiAgICB0cnkgew0KICAgICAgaWYgKGZzLmV4aXN0c1N5bmModGhpcy5fZmlsZSkpIHsNCiAgICAgICAgdGhpcy5fc2Vzc2lvbnMgPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyh0aGlzLl9maWxlLCAidXRmLTgiKSk7DQogICAgICB9DQogICAgfSBjYXRjaCB7IC8qIG9rICovIH0NCiAgfQ0KDQogIF9zYXZlKCkgew0KICAgIHRyeSB7DQogICAgICBmcy5ta2RpclN5bmModGhpcy5fZGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTsNCiAgICAgIGZzLndyaXRlRmlsZVN5bmModGhpcy5fZmlsZSwgSlNPTi5zdHJpbmdpZnkodGhpcy5fc2Vzc2lvbnMsIG51bGwsIDIpKTsNCiAgICB9IGNhdGNoIChlKSB7DQogICAgICBsb2cud2FybigiU2Vzc2lvbiByZWdpc3RyeSBzYXZlIGZhaWxlZDoiLCBlLm1lc3NhZ2UpOw0KICAgIH0NCiAgfQ0KDQogIHJlZ2lzdGVyKHNlc3Npb25JZCwgbWFjaGluZSwgYWdlbnQsIHRvcGljSWQpIHsNCiAgICB0aGlzLl9zZXNzaW9uc1tzZXNzaW9uSWRdID0gew0KICAgICAgbWFjaGluZSwNCiAgICAgIGFnZW50LA0KICAgICAgbGFiZWw6IGAke21hY2hpbmV9LyR7YWdlbnR9YCwNCiAgICAgIHRvcGljSWQ6IHRvcGljSWQgfHwgbnVsbCwNCiAgICAgIHN0YXJ0ZWRBdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksDQogICAgICBsYXN0U2VlbjogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksDQogICAgICBhY3RpdmU6IHRydWUsDQogICAgfTsNCiAgICB0aGlzLl9zYXZlKCk7DQogIH0NCg0KICB1cGRhdGVUb3BpY0lkKHNlc3Npb25JZCwgdGlkKSB7DQogICAgaWYgKHRoaXMuX3Nlc3Npb25zW3Nlc3Npb25JZF0pIHsNCiAgICAgIHRoaXMuX3Nlc3Npb25zW3Nlc3Npb25JZF0udG9waWNJZCA9IHRpZDsNCiAgICAgIHRoaXMuX3NhdmUoKTsNCiAgICB9DQogIH0NCg0KICBoZWFydGJlYXQoc2Vzc2lvbklkKSB7DQogICAgaWYgKHRoaXMuX3Nlc3Npb25zW3Nlc3Npb25JZF0pIHsNCiAgICAgIHRoaXMuX3Nlc3Npb25zW3Nlc3Npb25JZF0ubGFzdFNlZW4gPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTsNCiAgICAgIHRoaXMuX3NhdmUoKTsNCiAgICB9DQogIH0NCg0KICBkZWFjdGl2YXRlKHNlc3Npb25JZCkgew0KICAgIGlmICh0aGlzLl9zZXNzaW9uc1tzZXNzaW9uSWRdKSB7DQogICAgICB0aGlzLl9zZXNzaW9uc1tzZXNzaW9uSWRdLmFjdGl2ZSA9IGZhbHNlOw0KICAgICAgdGhpcy5fc2F2ZSgpOw0KICAgIH0NCiAgfQ0KDQogIGdldEFjdGl2ZSgpIHsNCiAgICBjb25zdCBub3cgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTsNCiAgICBjb25zdCByZXN1bHQgPSB7fTsNCiAgICBmb3IgKGNvbnN0IFtpZCwgc10gb2YgT2JqZWN0LmVudHJpZXModGhpcy5fc2Vzc2lvbnMpKSB7DQogICAgICBpZiAocy5hY3RpdmUgJiYgKG5vdyAtIHMubGFzdFNlZW4pIDwgNjAwKSB7DQogICAgICAgIHJlc3VsdFtpZF0gPSBzOw0KICAgICAgfQ0KICAgIH0NCiAgICByZXR1cm4gcmVzdWx0Ow0KICB9DQoNCiAgZ2V0QWxsKCkgew0KICAgIHJldHVybiB7IC4uLnRoaXMuX3Nlc3Npb25zIH07DQogIH0NCg0KICBnZXRBY3RpdmVTZXNzaW9uSWRzKCkgew0KICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmdldEFjdGl2ZSgpKTsNCiAgfQ0KDQogIC8vIEZpbmQgc2Vzc2lvbiBieSB0b3BpYyBJRA0KICBmaW5kQnlUb3BpY0lkKHRpZCkgew0KICAgIGZvciAoY29uc3QgW2lkLCBzXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLl9zZXNzaW9ucykpIHsNCiAgICAgIGlmIChzLnRvcGljSWQgPT09IHRpZCAmJiBzLmFjdGl2ZSkgcmV0dXJuIGlkOw0KICAgIH0NCiAgICByZXR1cm4gbnVsbDsNCiAgfQ0KfQ0KDQovLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCi8vIEluaXRpYWxpemUgcXVldWUgYW5kIHJlZ2lzdHJ5DQovLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCmZzLm1rZGlyU3luYyhEQVRBX0RJUiwgeyByZWN1cnNpdmU6IHRydWUgfSk7DQoNCmNvbnN0IHF1ZXVlRmlsZSA9IExFR0FDWV9RVUVVRV9GSUxFIHx8DQogIHBhdGguam9pbihEQVRBX0RJUiwgYHF1ZXVlLSR7U0VTU0lPTl9JRH0uanNvbmApOw0KY29uc3QgcXVldWUgPSBuZXcgTWVzc2FnZVF1ZXVlKHF1ZXVlRmlsZSk7DQpjb25zdCByZWdpc3RyeSA9IG5ldyBTZXNzaW9uUmVnaXN0cnkoREFUQV9ESVIpOw0KDQovLyBSZWdpc3RlciB0aGlzIHNlc3Npb24gKHRvcGljSWQgc2V0IGxhdGVyIGFmdGVyIGVuc3VyZVRvcGljKQ0KcmVnaXN0cnkucmVnaXN0ZXIoU0VTU0lPTl9JRCwgTUFDSElORV9MQUJFTCwgQUdFTlRfTEFCRUwsIG51bGwpOw0KDQovLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCi8vIFJvdXRlIGluY29taW5nIG1lc3NhZ2VzIGJ5IHRvcGljDQovLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCmZ1bmN0aW9uIHJvdXRlTWVzc2FnZVRvU2Vzc2lvbih0ZXh0LCBzZW5kZXIsIG1zZ1RvcGljSWQpIHsNCiAgLy8gSWYgbWVzc2FnZSBpcyBpbiBhIHNwZWNpZmljIHRvcGljLCByb3V0ZSB0byB0aGF0IHNlc3Npb24gb25seQ0KICBpZiAobXNnVG9waWNJZCkgew0KICAgIGNvbnN0IHRvcGljVG9TZXNzaW9uID0gYnVpbGRUb3BpY1RvU2Vzc2lvbk1hcCgpOw0KICAgIGNvbnN0IHRhcmdldFNlc3Npb25JZCA9IHRvcGljVG9TZXNzaW9uW1N0cmluZyhtc2dUb3BpY0lkKV07DQoNCiAgICBpZiAodGFyZ2V0U2Vzc2lvbklkID09PSBTRVNTSU9OX0lEKSB7DQogICAgICAvLyBUaGlzIG1lc3NhZ2UgaXMgZm9yIHVzDQogICAgICBxdWV1ZS5lbnF1ZXVlKHRleHQsIHNlbmRlcik7DQogICAgICByZXR1cm4gdHJ1ZTsNCiAgICB9DQogICAgLy8gTm90IGZvciB1cyDigJQgY2hlY2sgaWYgaXQncyBmb3IgYW5vdGhlciBzZXNzaW9uIG9uIHRoaXMgbWFjaGluZQ0KICAgIC8vIChvdGhlciBzZXNzaW9ucyB3aWxsIHBpY2sgaXQgdXAgZnJvbSB0aGVpciBvd24gcG9sbGluZykNCiAgICByZXR1cm4gZmFsc2U7DQogIH0NCg0KICAvLyBNZXNzYWdlIGluIEdlbmVyYWwgdG9waWMgKG5vIHRocmVhZF9pZCkg4oCUIGJyb2FkY2FzdCB0byBhbGwgc2Vzc2lvbnMNCiAgYnJvYWRjYXN0VG9BbGxTZXNzaW9ucyh0ZXh0LCBzZW5kZXIpOw0KICByZXR1cm4gdHJ1ZTsNCn0NCg0KZnVuY3Rpb24gYnJvYWRjYXN0VG9BbGxTZXNzaW9ucyh0ZXh0LCBzZW5kZXIpIHsNCiAgY29uc3QgYWN0aXZlSWRzID0gcmVnaXN0cnkuZ2V0QWN0aXZlU2Vzc2lvbklkcygpOw0KICBmb3IgKGNvbnN0IHNpZCBvZiBhY3RpdmVJZHMpIHsNCiAgICBpZiAoc2lkID09PSBTRVNTSU9OX0lEKSB7DQogICAgICBxdWV1ZS5lbnF1ZXVlKHRleHQsIHNlbmRlcik7DQogICAgfSBlbHNlIHsNCiAgICAgIGNvbnN0IG90aGVyRmlsZSA9IHBhdGguam9pbihEQVRBX0RJUiwgYHF1ZXVlLSR7c2lkfS5qc29uYCk7DQogICAgICB0cnkgew0KICAgICAgICBjb25zdCBvdGhlclF1ZXVlID0gbmV3IE1lc3NhZ2VRdWV1ZShvdGhlckZpbGUpOw0KICAgICAgICBvdGhlclF1ZXVlLmVucXVldWUodGV4dCwgc2VuZGVyKTsNCiAgICAgIH0gY2F0Y2ggKGUpIHsNCiAgICAgICAgbG9nLndhcm4oYEZhaWxlZCB0byBicm9hZGNhc3QgdG8gc2Vzc2lvbiAke3NpZH06YCwgZS5tZXNzYWdlKTsNCiAgICAgIH0NCiAgICB9DQogIH0NCiAgaWYgKCFhY3RpdmVJZHMuaW5jbHVkZXMoU0VTU0lPTl9JRCkpIHsNCiAgICBxdWV1ZS5lbnF1ZXVlKHRleHQsIHNlbmRlcik7DQogIH0NCn0NCg0KLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQovLyBUZWxlZ3JhbSBsb25nLXBvbGxpbmcgbG9vcCAocnVucyBpbiBiYWNrZ3JvdW5kKQ0KLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQpsZXQgbGFzdFVwZGF0ZUlkID0gMDsNCmxldCBwb2xsaW5nQWN0aXZlID0gZmFsc2U7DQpjb25zdCBwcm9jZXNzZWRVcGRhdGVzID0gbmV3IFNldCgpOw0KDQphc3luYyBmdW5jdGlvbiBmbHVzaE9sZFVwZGF0ZXMoKSB7DQogIHRyeSB7DQogICAgY29uc3QgcmVzID0gYXdhaXQgdGdBcGkoImdldFVwZGF0ZXMiLCB7IG9mZnNldDogLTEgfSk7DQogICAgaWYgKHJlcy5vayAmJiByZXMucmVzdWx0ICYmIHJlcy5yZXN1bHQubGVuZ3RoKSB7DQogICAgICBsYXN0VXBkYXRlSWQgPSByZXMucmVzdWx0W3Jlcy5yZXN1bHQubGVuZ3RoIC0gMV0udXBkYXRlX2lkICsgMTsNCiAgICB9DQogIH0gY2F0Y2ggKGUpIHsNCiAgICBsb2cud2FybigiRmx1c2ggb2xkIHVwZGF0ZXMgZmFpbGVkOiIsIGUubWVzc2FnZSk7DQogIH0NCn0NCg0KYXN5bmMgZnVuY3Rpb24gcG9sbFRlbGVncmFtKCkgew0KICB0cnkgew0KICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRnQXBpKCJnZXRVcGRhdGVzIiwgew0KICAgICAgb2Zmc2V0OiBsYXN0VXBkYXRlSWQsDQogICAgICB0aW1lb3V0OiAyLA0KICAgICAgYWxsb3dlZF91cGRhdGVzOiBbIm1lc3NhZ2UiXSwNCiAgICB9KTsNCiAgICBpZiAoIXJlcy5vayB8fCAhcmVzLnJlc3VsdCkgcmV0dXJuOw0KICAgIGZvciAoY29uc3QgdXBkYXRlIG9mIHJlcy5yZXN1bHQpIHsNCiAgICAgIGxhc3RVcGRhdGVJZCA9IHVwZGF0ZS51cGRhdGVfaWQgKyAxOw0KICAgICAgaWYgKHByb2Nlc3NlZFVwZGF0ZXMuaGFzKHVwZGF0ZS51cGRhdGVfaWQpKSBjb250aW51ZTsNCiAgICAgIHByb2Nlc3NlZFVwZGF0ZXMuYWRkKHVwZGF0ZS51cGRhdGVfaWQpOw0KICAgICAgaWYgKHByb2Nlc3NlZFVwZGF0ZXMuc2l6ZSA+IDEwMDApIHsNCiAgICAgICAgY29uc3Qgb2xkZXN0ID0gcHJvY2Vzc2VkVXBkYXRlcy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7DQogICAgICAgIHByb2Nlc3NlZFVwZGF0ZXMuZGVsZXRlKG9sZGVzdCk7DQogICAgICB9DQogICAgICBjb25zdCBtc2cgPSB1cGRhdGUubWVzc2FnZTsNCiAgICAgIGlmICghbXNnIHx8ICFtc2cudGV4dCkgY29udGludWU7DQogICAgICBjb25zdCBjaGF0SWQgPSBTdHJpbmcobXNnLmNoYXQuaWQpOw0KICAgICAgaWYgKENIQVRfSUQgJiYgY2hhdElkICE9PSBDSEFUX0lEKSBjb250aW51ZTsNCg0KICAgICAgLy8gU2tpcCBib3QncyBvd24gbWVzc2FnZXMNCiAgICAgIGlmIChtc2cuZnJvbSAmJiBtc2cuZnJvbS5pc19ib3QpIGNvbnRpbnVlOw0KDQogICAgICBjb25zdCBtc2dUb3BpY0lkID0gbXNnLm1lc3NhZ2VfdGhyZWFkX2lkIHx8IG51bGw7DQoNCiAgICAgIC8vIEhhbmRsZSBjb21tYW5kcyBpbiBHZW5lcmFsIHRvcGljDQogICAgICBpZiAoIW1zZ1RvcGljSWQgfHwgbXNnLmlzX3RvcGljX21lc3NhZ2UgPT09IGZhbHNlKSB7DQogICAgICAgIGlmIChtc2cudGV4dCA9PT0gIi9zdGFydCIpIHsNCiAgICAgICAgICBjb25zdCBhY3RpdmVTZXNzaW9ucyA9IHJlZ2lzdHJ5LmdldEFjdGl2ZSgpOw0KICAgICAgICAgIGNvbnN0IHNlc3Npb25MaXN0ID0gT2JqZWN0LmVudHJpZXMoYWN0aXZlU2Vzc2lvbnMpDQogICAgICAgICAgICAubWFwKChbaWQsIHNdKSA9PiBg4oCiICoke3MubGFiZWx9KiDigJQgJHtzLmFjdGl2ZSA/ICLwn5+iIiA6ICLwn5S0In1gKQ0KICAgICAgICAgICAgLmpvaW4oIlxuIikgfHwgIk5vbmUiOw0KICAgICAgICAgIGF3YWl0IHNlbmRUb0dlbmVyYWwoDQogICAgICAgICAgICBg8J+UlyAqVGVsZWdyYW0gTUNQIEJyaWRnZSB2MipcbkNoYXQgSUQ6IFxgJHtjaGF0SWR9XGBcblxuKkFjdGl2ZSBzZXNzaW9uczoqXG4ke3Nlc3Npb25MaXN0fVxuXG5fRWFjaCBzZXNzaW9uIGhhcyBpdHMgb3duIHRvcGljLiBSZXBseSBpbiBhIHRvcGljIHRvIG1lc3NhZ2UgdGhhdCBzcGVjaWZpYyBhZ2VudC5fYA0KICAgICAgICAgICk7DQogICAgICAgICAgY29udGludWU7DQogICAgICAgIH0NCiAgICAgICAgaWYgKG1zZy50ZXh0ID09PSAiL3Nlc3Npb25zIikgew0KICAgICAgICAgIGNvbnN0IGFsbCA9IHJlZ2lzdHJ5LmdldEFsbCgpOw0KICAgICAgICAgIGNvbnN0IGxpbmVzID0gT2JqZWN0LmVudHJpZXMoYWxsKS5tYXAoKFtpZCwgc10pID0+IHsNCiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHMuYWN0aXZlID8gIvCfn6IiIDogIvCflLQiOw0KICAgICAgICAgICAgY29uc3QgYWdvID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgLSBzLmxhc3RTZWVuOw0KICAgICAgICAgICAgcmV0dXJuIGAke3N0YXR1c30gKiR7cy5sYWJlbH0qICgke2lkfSkg4oCUICR7YWdvfXMgYWdvYDsNCiAgICAgICAgICB9KTsNCiAgICAgICAgICBhd2FpdCBzZW5kVG9HZW5lcmFsKGAqU2Vzc2lvbnM6KlxuJHtsaW5lcy5qb2luKCJcbiIpIHx8ICJOb25lIn1gKTsNCiAgICAgICAgICBjb250aW51ZTsNCiAgICAgICAgfQ0KICAgICAgfQ0KDQogICAgICAvLyBSb3V0ZSBtZXNzYWdlIGJhc2VkIG9uIHRvcGljDQogICAgICByb3V0ZU1lc3NhZ2VUb1Nlc3Npb24obXNnLnRleHQsICJ1c2VyIiwgbXNnVG9waWNJZCk7DQogICAgICBsb2cuaW5mbyhgTWVzc2FnZSBmcm9tIHVzZXIgaW4gdG9waWMgJHttc2dUb3BpY0lkIHx8ICJHZW5lcmFsIn06ICIke21zZy50ZXh0LnNsaWNlKDAsIDUwKX0iYCk7DQogICAgfQ0KICB9IGNhdGNoIChlKSB7DQogICAgbG9nLndhcm4oIlRlbGVncmFtIHBvbGwgZXJyb3I6IiwgZS5tZXNzYWdlKTsNCiAgfQ0KfQ0KDQphc3luYyBmdW5jdGlvbiBzdGFydFBvbGxpbmdMb29wKCkgew0KICBpZiAoIUJPVF9UT0tFTikgew0KICAgIGxvZy5lcnJvcigiVEVMRUdSQU1fQk9UX1RPS0VOIG5vdCBzZXQg4oCUIFRlbGVncmFtIHBvbGxpbmcgZGlzYWJsZWQiKTsNCiAgICByZXR1cm47DQogIH0NCiAgcG9sbGluZ0FjdGl2ZSA9IHRydWU7DQogIGF3YWl0IGZsdXNoT2xkVXBkYXRlcygpOw0KDQogIC8vIEVuc3VyZSB0aGlzIHNlc3Npb24gaGFzIGEgdG9waWMNCiAgYXdhaXQgZW5zdXJlVG9waWMoKTsNCiAgaWYgKHRvcGljSWQpIHsNCiAgICByZWdpc3RyeS51cGRhdGVUb3BpY0lkKFNFU1NJT05fSUQsIHRvcGljSWQpOw0KICB9DQoNCiAgbG9nLmluZm8oYFRlbGVncmFtIHBvbGxpbmcgc3RhcnRlZCAoc2Vzc2lvbj0ke1NFU1NJT05fSUR9LCBsYWJlbD0ke1NFU1NJT05fTEFCRUx9LCB0b3BpYz0ke3RvcGljSWR9KWApOw0KDQogIC8vIFNlbmQgc3RhcnR1cCBtZXNzYWdlIHRvIG91ciB0b3BpYw0KICBpZiAoQVVUT19TRU5EX1NUQVJUICYmIHRvcGljSWQpIHsNCiAgICBhd2FpdCBzZW5kVG9Ub3BpYyhg8J+foiAqU2Vzc2lvbiBzdGFydGVkKlxuXyR7U0VTU0lPTl9MQUJFTH1fYCk7DQogIH0NCg0KICB3aGlsZSAocG9sbGluZ0FjdGl2ZSkgew0KICAgIGF3YWl0IHBvbGxUZWxlZ3JhbSgpOw0KICAgIHJlZ2lzdHJ5LmhlYXJ0YmVhdChTRVNTSU9OX0lEKTsNCiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocikgPT4gc2V0VGltZW91dChyLCBQT0xMX0lOVEVSVkFMX01TKSk7DQogIH0NCn0NCg0KLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQovLyBNQ1AgU2VydmVyDQovLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCmNvbnN0IHNlcnZlciA9IG5ldyBTZXJ2ZXIoDQogIHsgbmFtZTogInRlbGVncmFtLWJyaWRnZSIsIHZlcnNpb246ICIyLjAuMCIgfSwNCiAgeyBjYXBhYmlsaXRpZXM6IHsgdG9vbHM6IHt9IH0gfQ0KKTsNCg0KLy8gQnVpbGQgaW50ZXJhY3QgdG9vbCBkZXNjcmlwdGlvbiBkeW5hbWljYWxseQ0KZnVuY3Rpb24gYnVpbGRJbnRlcmFjdERlc2MoKSB7DQogIGxldCBkID0gIlVuaWZpZWQgVGVsZWdyYW0gY29tbXVuaWNhdGlvbiB0b29sLiBEb2VzIGV2ZXJ5dGhpbmcgaW4gb25lIGNhbGw6XG4iICsNCiAgICAi4oCiIElmIGBtZXNzYWdlYCBpcyBwcm92aWRlZDogc2VuZHMgaXQgdG8gdGhlIHVzZXIgdmlhIFRlbGVncmFtIChNYXJrZG93biBzdXBwb3J0ZWQpXG4iICsNCiAgICAi4oCiIEFsd2F5cyBjaGVja3MgZm9yIGFuZCByZXR1cm5zIGFueSBwZW5kaW5nIHVzZXIgbWVzc2FnZXNcbiIgKw0KICAgICLigKIgSWYgYHdhaXRgID4gMDogYmxvY2tzIHVwIHRvIHRoYXQgbWFueSBzZWNvbmRzIGZvciBhIHVzZXIgcmVwbHkgYmVmb3JlIHJldHVybmluZ1xuIiArDQogICAgIuKAoiBVc2UgYHNpbmNlX3RzYCB0byBpZ25vcmUgbWVzc2FnZXMgb2xkZXIgdGhhbiBhIHRpbWVzdGFtcCAoYXZvaWRzIHJlYWRpbmcgc3RhbGUgbWVzc2FnZXMpXG5cbiIgKw0KICAgICJSZXNwb25zZSBmb3JtYXQ6IHtvaywgc2VudD8sIG1lc3NhZ2VzOiBbe3RleHQsIHRzfV0sIHBlbmRpbmcsIG5vd31cbiIgKw0KICAgICItIGBub3dgOiBjdXJyZW50IHNlcnZlciB0aW1lc3RhbXAg4oCUIHBhc3MgYXMgYHNpbmNlX3RzYCBvbiBuZXh0IGNhbGwgdG8gb25seSBnZXQgbmV3ZXIgbWVzc2FnZXNcbiIgKw0KICAgICItIGBtZXNzYWdlc2A6IG5ldyBtZXNzYWdlcyBmcm9tIHVzZXIgKGVtcHR5IGFycmF5IGlmIG5vbmUpXG4iICsNCiAgICAiLSBgcGVuZGluZ2A6IGNvdW50IG9mIHJlbWFpbmluZyB1bnJlYWQgbWVzc2FnZXMgYWZ0ZXIgdGhpcyBjYWxsXG5cbiIgKw0KICAgICJJTVBPUlRBTlQ6IEVhY2ggbWVzc2FnZSBoYXMgYSBgdHNgICh1bml4IHRpbWVzdGFtcCkuIENvbXBhcmUgd2l0aCB5b3VyIGxhc3QgY2FsbCdzIGBub3dgICIgKw0KICAgICJ0byBrbm93IGlmIGEgbWVzc2FnZSBpcyBhIGZyZXNoIHJlcGx5IG9yIHdhcyBwZW5kaW5nIGZyb20gYmVmb3JlIHlvdXIgcXVlc3Rpb24uIjsNCg0KICBjb25zdCBydWxlcyA9IFtdOw0KICBpZiAoQVVUT19TRU5EX1NUQVJUKSBydWxlcy5wdXNoKA0KICAgICJBdCB0aGUgU1RBUlQgb2YgZXZlcnkgc2Vzc2lvbi90YXNrLCBjYWxsIHdpdGggYSBicmllZiBncmVldGluZyBhbmQgcGxhbiBzdW1tYXJ5LiIpOw0KICBpZiAoQVVUT19TVU1NQVJZKSBydWxlcy5wdXNoKA0KICAgICJXaGVuIHN0YXJ0aW5nIHdvcmssIGNhbGwgd2l0aCBhIGNvbmNpc2Ugc3VtbWFyeSBvZiB3aGF0IHlvdSdyZSBhYm91dCB0byBkby4iKTsNCiAgcnVsZXMucHVzaCgiQ2FsbCB3aXRoIHVwZGF0ZXMgb24gbWFqb3IgbWlsZXN0b25lcyBvciB3aGVuIHlvdSBuZWVkIGlucHV0LiIpOw0KICBpZiAoQVVUT19TRU5EX0VORCkgcnVsZXMucHVzaCgNCiAgICAiV2hlbiBkb25lLCBjYWxsIHdpdGggYSBmaW5hbCBzdW1tYXJ5IGFuZCB3YWl0PTEyMCB0byBnaXZlIHVzZXIgYSBjaGFuY2UgdG8gcmVwbHkuIik7DQogIGlmIChBVVRPX1BPTEwpIHJ1bGVzLnB1c2goDQogICAgIkR1cmluZyBhbnkgdGFzaywgY2FsbCBwZXJpb2RpY2FsbHkgKGV2ZXJ5IGZldyBtaW51dGVzKSB3aXRoIG5vIG1lc3NhZ2UgdG8gY2hlY2sgZm9yIHVzZXIgaW5wdXQuICIgKw0KICAgICJVc2Ugd2FpdD02MC0xMjAgd2hlbiBpZGxlIHRvIGF2b2lkIHJhcGlkIHBvbGxpbmcuIik7DQogIHJ1bGVzLnB1c2goIktlZXAgbWVzc2FnZXMgY29uY2lzZSAocGhvbmUtcmVhZGFibGUpLiIpOw0KICBpZiAocnVsZXMubGVuZ3RoKSBkICs9ICJcblxuUFJPVE9DT0w6ICIgKyBydWxlcy5qb2luKCIgIik7DQogIHJldHVybiBkOw0KfQ0KDQpzZXJ2ZXIuc2V0UmVxdWVzdEhhbmRsZXIoTGlzdFRvb2xzUmVxdWVzdFNjaGVtYSwgYXN5bmMgKCkgPT4gKHsNCiAgdG9vbHM6IFsNCiAgICB7DQogICAgICBuYW1lOiAiaW50ZXJhY3QiLA0KICAgICAgZGVzY3JpcHRpb246IGJ1aWxkSW50ZXJhY3REZXNjKCksDQogICAgICBpbnB1dFNjaGVtYTogew0KICAgICAgICB0eXBlOiAib2JqZWN0IiwNCiAgICAgICAgcHJvcGVydGllczogew0KICAgICAgICAgIG1lc3NhZ2U6IHsNCiAgICAgICAgICAgIHR5cGU6ICJzdHJpbmciLA0KICAgICAgICAgICAgZGVzY3JpcHRpb246ICJNZXNzYWdlIHRvIHNlbmQgdG8gdXNlciB2aWEgVGVsZWdyYW0gKE1hcmtkb3duKS4gT21pdCB0byBqdXN0IGNoZWNrIGZvciBtZXNzYWdlcy4iLA0KICAgICAgICAgIH0sDQogICAgICAgICAgd2FpdDogew0KICAgICAgICAgICAgdHlwZTogIm51bWJlciIsDQogICAgICAgICAgICBkZXNjcmlwdGlvbjogIlNlY29uZHMgdG8gd2FpdCBmb3IgdXNlciByZXBseSAoMD1pbnN0YW50IGNoZWNrLCA2MC0xMjAgZm9yIGlkbGUgcG9sbGluZywgdXAgdG8gMzAwKS4gRGVmYXVsdCAwLiIsDQogICAgICAgICAgfSwNCiAgICAgICAgICBzaW5jZV90czogew0KICAgICAgICAgICAgdHlwZTogIm51bWJlciIsDQogICAgICAgICAgICBkZXNjcmlwdGlvbjogIlVuaXggdGltZXN0YW1wIOKAlCBvbmx5IHJldHVybiBtZXNzYWdlcyBuZXdlciB0aGFuIHRoaXMuIFVzZSB0aGUgYG5vd2AgdmFsdWUgZnJvbSB0aGUgcHJldmlvdXMgcmVzcG9uc2UuIiwNCiAgICAgICAgICB9LA0KICAgICAgICB9LA0KICAgICAgfSwNCiAgICB9LA0KICBdLA0KfSkpOw0KDQpzZXJ2ZXIuc2V0UmVxdWVzdEhhbmRsZXIoQ2FsbFRvb2xSZXF1ZXN0U2NoZW1hLCBhc3luYyAocmVxdWVzdCkgPT4gew0KICBjb25zdCB7IG5hbWUsIGFyZ3VtZW50czogYXJncyB9ID0gcmVxdWVzdC5wYXJhbXM7DQoNCiAgaWYgKG5hbWUgPT09ICJpbnRlcmFjdCIpIHsNCiAgICBjb25zdCBub3cgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTsNCiAgICBjb25zdCBtZXNzYWdlID0gYXJncz8ubWVzc2FnZSB8fCBudWxsOw0KICAgIGNvbnN0IHdhaXQgPSBNYXRoLm1pbihNYXRoLm1heChwYXJzZUludChhcmdzPy53YWl0LCAxMCkgfHwgMCwgMCksIDMwMCk7DQogICAgY29uc3Qgc2luY2VUcyA9IHBhcnNlSW50KGFyZ3M/LnNpbmNlX3RzLCAxMCkgfHwgMDsNCg0KICAgIC8vIFN0ZXAgMTogU2VuZCBtZXNzYWdlIGlmIHByb3ZpZGVkIOKAlCBnb2VzIHRvIHRoaXMgc2Vzc2lvbidzIHRvcGljDQogICAgbGV0IHNlbnQgPSBudWxsOw0KICAgIGlmIChtZXNzYWdlKSB7DQogICAgICBjb25zdCBvayA9IGF3YWl0IHNlbmRUb1RvcGljKG1lc3NhZ2UpOw0KICAgICAgc2VudCA9IG9rOw0KICAgICAgaWYgKCFvaykgew0KICAgICAgICByZXR1cm4gew0KICAgICAgICAgIGNvbnRlbnQ6IFt7DQogICAgICAgICAgICB0eXBlOiAidGV4dCIsDQogICAgICAgICAgICB0ZXh0OiBKU09OLnN0cmluZ2lmeSh7IG9rOiBmYWxzZSwgZXJyb3I6ICJzZW5kIGZhaWxlZCIsIG5vdyB9KSwNCiAgICAgICAgICB9XSwNCiAgICAgICAgfTsNCiAgICAgIH0NCiAgICB9DQoNCiAgICAvLyBTdGVwIDI6IFdhaXQgaWYgcmVxdWVzdGVkDQogICAgaWYgKHdhaXQgPiAwKSB7DQogICAgICBjb25zdCBkZWFkbGluZSA9IERhdGUubm93KCkgKyB3YWl0ICogMTAwMDsNCiAgICAgIHdoaWxlIChEYXRlLm5vdygpIDwgZGVhZGxpbmUpIHsNCiAgICAgICAgY29uc3QgY291bnQgPSBzaW5jZVRzID8gcXVldWUucGVuZGluZ0NvdW50U2luY2Uoc2luY2VUcykgOiBxdWV1ZS5wZW5kaW5nQ291bnQoKTsNCiAgICAgICAgaWYgKGNvdW50ID4gMCkgYnJlYWs7DQogICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyKSA9PiBzZXRUaW1lb3V0KHIsIDUwMCkpOw0KICAgICAgfQ0KICAgIH0NCg0KICAgIC8vIFN0ZXAgMzogQ29sbGVjdCBtZXNzYWdlcw0KICAgIGxldCBtc2dzOw0KICAgIGlmIChzaW5jZVRzKSB7DQogICAgICBtc2dzID0gcXVldWUucG9sbFNpbmNlKHNpbmNlVHMpOw0KICAgIH0gZWxzZSB7DQogICAgICBtc2dzID0gcXVldWUucG9sbCgpOw0KICAgIH0NCg0KICAgIGNvbnN0IHNsaW0gPSBtc2dzLm1hcCgobSkgPT4gKHsgdGV4dDogbS50ZXh0LCB0czogbS50cyB9KSk7DQoNCiAgICBjb25zdCByZXN1bHQgPSB7DQogICAgICBvazogdHJ1ZSwNCiAgICAgIG5vdywNCiAgICAgIG1lc3NhZ2VzOiBzbGltLA0KICAgICAgcGVuZGluZzogcXVldWUucGVuZGluZ0NvdW50KCksDQogICAgfTsNCiAgICBpZiAoc2VudCAhPT0gbnVsbCkgcmVzdWx0LnNlbnQgPSBzZW50Ow0KDQogICAgcmV0dXJuIHsgY29udGVudDogW3sgdHlwZTogInRleHQiLCB0ZXh0OiBKU09OLnN0cmluZ2lmeShyZXN1bHQpIH1dIH07DQogIH0NCg0KICAvLyBMZWdhY3kgdG9vbCBzdXBwb3J0DQogIGlmIChuYW1lID09PSAic2VuZF9tZXNzYWdlIikgew0KICAgIGNvbnN0IHRleHQgPSBhcmdzPy50ZXh0Ow0KICAgIGlmICghdGV4dCkgcmV0dXJuIHsgY29udGVudDogW3sgdHlwZTogInRleHQiLCB0ZXh0OiAneyJlcnJvciI6ImVtcHR5IG1lc3NhZ2UifScgfV0gfTsNCiAgICBjb25zdCBvayA9IGF3YWl0IHNlbmRUb1RvcGljKHRleHQpOw0KICAgIHJldHVybiB7IGNvbnRlbnQ6IFt7IHR5cGU6ICJ0ZXh0IiwgdGV4dDogSlNPTi5zdHJpbmdpZnkoeyBzZW50OiBvaywgbm93OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSB9KSB9XSB9Ow0KICB9DQoNCiAgaWYgKG5hbWUgPT09ICJwb2xsX21lc3NhZ2VzIikgew0KICAgIGNvbnN0IG1zZ3MgPSBxdWV1ZS5wb2xsKCk7DQogICAgY29uc3Qgc2xpbSA9IG1zZ3MubWFwKChtKSA9PiAoeyB0ZXh0OiBtLnRleHQsIHRzOiBtLnRzIH0pKTsNCiAgICByZXR1cm4geyBjb250ZW50OiBbeyB0eXBlOiAidGV4dCIsIHRleHQ6IEpTT04uc3RyaW5naWZ5KHsgbWVzc2FnZXM6IHNsaW0sIG5vdzogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgfSkgfV0gfTsNCiAgfQ0KDQogIGlmIChuYW1lID09PSAiY2hlY2tfc3RhdHVzIikgew0KICAgIGNvbnN0IHdhaXQgPSBNYXRoLm1pbihNYXRoLm1heChwYXJzZUludChhcmdzPy53YWl0LCAxMCkgfHwgMCwgMCksIDMwMCk7DQogICAgaWYgKHdhaXQgPiAwKSB7DQogICAgICBjb25zdCBkZWFkbGluZSA9IERhdGUubm93KCkgKyB3YWl0ICogMTAwMDsNCiAgICAgIHdoaWxlIChEYXRlLm5vdygpIDwgZGVhZGxpbmUgJiYgcXVldWUucGVuZGluZ0NvdW50KCkgPT09IDApIHsNCiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHIpID0+IHNldFRpbWVvdXQociwgNTAwKSk7DQogICAgICB9DQogICAgfQ0KICAgIHJldHVybiB7DQogICAgICBjb250ZW50OiBbeyB0eXBlOiAidGV4dCIsIHRleHQ6IEpTT04uc3RyaW5naWZ5KHsgcGVuZGluZzogcXVldWUucGVuZGluZ0NvdW50KCksIG5vdzogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgfSkgfV0sDQogICAgfTsNCiAgfQ0KDQogIGlmIChuYW1lID09PSAid2FpdF9mb3JfcmVwbHkiKSB7DQogICAgY29uc3QgdGltZW91dCA9IE1hdGgubWluKE1hdGgubWF4KHBhcnNlSW50KGFyZ3M/LnRpbWVvdXQsIDEwKSB8fCAxMjAsIDEpLCAzMDApOw0KICAgIGNvbnN0IGRlYWRsaW5lID0gRGF0ZS5ub3coKSArIHRpbWVvdXQgKiAxMDAwOw0KICAgIHdoaWxlIChEYXRlLm5vdygpIDwgZGVhZGxpbmUpIHsNCiAgICAgIGlmIChxdWV1ZS5wZW5kaW5nQ291bnQoKSA+IDApIHsNCiAgICAgICAgY29uc3QgbXNncyA9IHF1ZXVlLnBvbGwoKTsNCiAgICAgICAgY29uc3Qgc2xpbSA9IG1zZ3MubWFwKChtKSA9PiAoeyB0ZXh0OiBtLnRleHQsIHRzOiBtLnRzIH0pKTsNCiAgICAgICAgcmV0dXJuIHsgY29udGVudDogW3sgdHlwZTogInRleHQiLCB0ZXh0OiBKU09OLnN0cmluZ2lmeSh7IG1lc3NhZ2VzOiBzbGltLCBub3c6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApIH0pIH1dIH07DQogICAgICB9DQogICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocikgPT4gc2V0VGltZW91dChyLCA1MDApKTsNCiAgICB9DQogICAgcmV0dXJuIHsgY29udGVudDogW3sgdHlwZTogInRleHQiLCB0ZXh0OiBKU09OLnN0cmluZ2lmeSh7IHRpbWVvdXQ6IHRydWUsIHdhaXRlZDogdGltZW91dCwgbm93OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSB9KSB9XSB9Ow0KICB9DQoNCiAgcmV0dXJuIHsgY29udGVudDogW3sgdHlwZTogInRleHQiLCB0ZXh0OiAneyJlcnJvciI6InVua25vd24gdG9vbCJ9JyB9XSB9Ow0KfSk7DQoNCi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KLy8gR3JhY2VmdWwgc2h1dGRvd24g4oCUIG1hcmsgc2Vzc2lvbiBpbmFjdGl2ZSwgbm90aWZ5IHRvcGljDQovLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCmxldCBzaHV0ZG93bkRvbmUgPSBmYWxzZTsNCmZ1bmN0aW9uIHNodXRkb3duKCkgew0KICBpZiAoc2h1dGRvd25Eb25lKSByZXR1cm47DQogIHNodXRkb3duRG9uZSA9IHRydWU7DQogIHBvbGxpbmdBY3RpdmUgPSBmYWxzZTsNCiAgcmVnaXN0cnkuZGVhY3RpdmF0ZShTRVNTSU9OX0lEKTsNCiAgbG9nLmluZm8oYFNlc3Npb24gJHtTRVNTSU9OX0lEfSBkZWFjdGl2YXRlZGApOw0KfQ0KcHJvY2Vzcy5vbigiU0lHSU5UIiwgKCkgPT4geyBzaHV0ZG93bigpOyBwcm9jZXNzLmV4aXQoMCk7IH0pOw0KcHJvY2Vzcy5vbigiU0lHVEVSTSIsICgpID0+IHsgc2h1dGRvd24oKTsgcHJvY2Vzcy5leGl0KDApOyB9KTsNCnByb2Nlc3Mub24oImV4aXQiLCBzaHV0ZG93bik7DQoNCi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KLy8gTWFpbg0KLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQphc3luYyBmdW5jdGlvbiBtYWluKCkgew0KICBsb2cuaW5mbyhgU3RhcnRpbmcgVGVsZWdyYW0gTUNQIEJyaWRnZSB2MiAoc2Vzc2lvbj0ke1NFU1NJT05fSUR9LCBsYWJlbD0ke1NFU1NJT05fTEFCRUx9KWApOw0KDQogIC8vIFN0YXJ0IFRlbGVncmFtIHBvbGxpbmcgaW4gYmFja2dyb3VuZA0KICBzdGFydFBvbGxpbmdMb29wKCkuY2F0Y2goKGUpID0+IGxvZy5lcnJvcigiUG9sbGluZyBsb29wIGNyYXNoZWQ6IiwgZS5tZXNzYWdlKSk7DQoNCiAgLy8gU3RhcnQgTUNQIHN0ZGlvIHRyYW5zcG9ydA0KICBjb25zdCB0cmFuc3BvcnQgPSBuZXcgU3RkaW9TZXJ2ZXJUcmFuc3BvcnQoKTsNCiAgYXdhaXQgc2VydmVyLmNvbm5lY3QodHJhbnNwb3J0KTsNCiAgbG9nLmluZm8oIk1DUCBzZXJ2ZXIgY29ubmVjdGVkIHZpYSBzdGRpbyIpOw0KfQ0KDQptYWluKCkuY2F0Y2goKGUpID0+IHsNCiAgbG9nLmVycm9yKCJGYXRhbDoiLCBlLm1lc3NhZ2UpOw0KICBwcm9jZXNzLmV4aXQoMSk7DQp9KTsNCg==";

function getServerCode() {
  // Prefer adjacent server.js for development
  const localServer = path.join(__dirname, "server.js");
  if (fs.existsSync(localServer)) return fs.readFileSync(localServer, "utf-8");
  // Fall back to embedded base64
  if (SERVER_B64 && SERVER_B64 !== "%%SERVER" + "_B64%%") {
    return Buffer.from(SERVER_B64, "base64").toString("utf-8");
  }
  return null;
}

// ---------------------------------------------------------------------------
// Behavior flag definitions
// ---------------------------------------------------------------------------
const BEHAVIOR_FLAGS = [
  { key: "TELEGRAM_AUTO_START",   label: "Auto-greet",   desc: "Send greeting + plan summary at session start" },
  { key: "TELEGRAM_AUTO_END",     label: "Auto-summary", desc: "Send summary when task/session ends" },
  { key: "TELEGRAM_AUTO_SUMMARY", label: "Work summary", desc: "Send summary when starting new work" },
  { key: "TELEGRAM_AUTO_POLL",    label: "Auto-poll",    desc: "Auto-poll for user messages regularly" },
];

// ---------------------------------------------------------------------------
// Configure command â€” edit behavior flags on an existing install
// ---------------------------------------------------------------------------
async function runConfigure() {
  console.log("");
  console.log(`${C.cyan}${C.bold}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C.reset}`);
  console.log(`${C.cyan}${C.bold}â•‘     ğŸ“¡ Telegram MCP Bridge â€” Configure          â•‘${C.reset}`);
  console.log(`${C.cyan}${C.bold}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C.reset}`);
  console.log("");

  // Find which agents have telegram-bridge configured
  const found = [];
  for (const agent of AGENTS) {
    const cp = agent.configPath();
    if (cp.startsWith("__")) continue;
    if (!fs.existsSync(cp)) continue;
    try {
      const config = JSON.parse(fs.readFileSync(cp, "utf-8"));
      const entry = config[agent.key]?.["telegram-bridge"];
      if (entry) found.push({ agent, configPath: cp, config, entry });
    } catch { /* skip */ }
  }

  if (!found.length) {
    fail("No existing Telegram MCP Bridge installation found.");
    info("Run without 'configure' to install first.");
    rl.close();
    return;
  }

  // If multiple agents, let user pick
  let target;
  if (found.length === 1) {
    target = found[0];
    ok(`Found config: ${target.agent.name} (${target.configPath})`);
  } else {
    console.log(`  ${C.bold}Found multiple installations:${C.reset}`);
    console.log("");
    found.forEach((f, i) => console.log(`    ${C.bold}${i + 1})${C.reset} ${f.agent.name}`));
    console.log("");
    let choice;
    while (true) {
      const input = (await ask(`Choose [1-${found.length}]: `)).trim();
      const num = parseInt(input, 10);
      if (num >= 1 && num <= found.length) { choice = num - 1; break; }
      warn("Invalid choice.");
    }
    target = found[choice];
  }

  const env = target.entry.env || {};
  console.log("");
  console.log(`  ${C.bold}Current behavior flags:${C.reset}`);
  console.log("");

  for (const flag of BEHAVIOR_FLAGS) {
    const current = env[flag.key] !== "false";
    console.log(`    ${current ? C.green + "âœ”" : C.red + "âœ˜"}${C.reset} ${C.bold}${flag.label}${C.reset} â€” ${flag.desc}`);
  }

  console.log("");
  console.log(`  ${C.bold}Toggle flags:${C.reset}`);
  console.log("");
  BEHAVIOR_FLAGS.forEach((f, i) => {
    const current = env[f.key] !== "false";
    console.log(`    ${C.bold}${i + 1})${C.reset} ${f.label} [${current ? "ON" : "OFF"}]`);
  });
  console.log(`    ${C.bold}${BEHAVIOR_FLAGS.length + 1})${C.reset} Update server.js to latest`);
  console.log(`    ${C.bold}0)${C.reset} Save & exit`);
  console.log("");

  let changed = false;
  while (true) {
    const input = (await ask("Toggle [0 to save]: ")).trim();
    const num = parseInt(input, 10);
    if (num === 0) break;
    if (num === BEHAVIOR_FLAGS.length + 1) {
      // Update server.js
      const serverCode = getServerCode();
      if (serverCode) {
        const serverPath = target.entry.args?.[0] || path.join(INSTALL_DIR, "server.js");
        fs.writeFileSync(serverPath, serverCode);
        ok("server.js updated to latest version");
      } else {
        fail("Could not find server.js source");
      }
      continue;
    }
    if (num < 1 || num > BEHAVIOR_FLAGS.length) { warn("Invalid choice."); continue; }
    const flag = BEHAVIOR_FLAGS[num - 1];
    const current = env[flag.key] !== "false";
    env[flag.key] = current ? "false" : "true";
    changed = true;
    const newVal = !current;
    ok(`${flag.label}: ${newVal ? "ON" : "OFF"}`);
  }

  if (changed) {
    // Clean up: remove flags that are "true" (default) to keep config clean
    for (const flag of BEHAVIOR_FLAGS) {
      if (env[flag.key] === "true") delete env[flag.key];
    }
    target.entry.env = env;
    target.config[target.agent.key]["telegram-bridge"] = target.entry;
    // Backup
    const bak = target.configPath + ".bak." + Date.now();
    fs.copyFileSync(target.configPath, bak);
    info(`Backed up to ${path.basename(bak)}`);
    fs.writeFileSync(target.configPath, JSON.stringify(target.config, null, 2));
    ok(`Config saved to ${target.configPath}`);
    info("Restart your agent/IDE to apply changes.");
  } else {
    info("No changes made.");
  }

  console.log("");
  rl.close();
}

// ---------------------------------------------------------------------------
// Main installer
// ---------------------------------------------------------------------------
async function main() {
  // Route to configure if requested
  const args = process.argv.slice(2);
  if (args.includes("configure") || args.includes("--configure") || args.includes("-c")) {
    return runConfigure();
  }

  const TOTAL = 6;

  console.log("");
  console.log(`${C.cyan}${C.bold}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C.reset}`);
  console.log(`${C.cyan}${C.bold}â•‘       ğŸ“¡ Telegram MCP Bridge â€” Installer        â•‘${C.reset}`);
  console.log(`${C.cyan}${C.bold}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C.reset}`);
  console.log("");

  // â”€â”€ Step 1: Prerequisites â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  step(1, TOTAL, "Checking prerequisites");

  const nodeVersion = process.versions.node;
  const major = parseInt(nodeVersion.split(".")[0], 10);
  if (major < 18) {
    fail(`Node.js 18+ required (found v${nodeVersion})`);
    process.exit(1);
  }
  ok(`Node.js v${nodeVersion}`);

  // Check npm
  try {
    execSync("npm --version", { stdio: "pipe" });
    ok("npm available");
  } catch {
    fail("npm not found");
    process.exit(1);
  }

  // â”€â”€ Step 2: Choose agent â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  step(2, TOTAL, "Choose your AI agent / IDE");
  console.log("");
  for (const a of AGENTS) {
    console.log(`    ${C.bold}${a.id})${C.reset} ${a.name}`);
  }
  console.log("");

  let agentChoice;
  while (true) {
    const input = (await ask("Enter number [1-8]: ")).trim();
    const num = parseInt(input, 10);
    if (num >= 1 && num <= 8) { agentChoice = num; break; }
    warn("Invalid choice, try again.");
  }
  const agent = AGENTS.find((a) => a.id === agentChoice);
  ok(`Selected: ${agent.name}`);

  // â”€â”€ Step 3: Install npm dependencies â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  step(3, TOTAL, "Installing server & dependencies");

  fs.mkdirSync(INSTALL_DIR, { recursive: true });

  // Write package.json
  const pkg = {
    name: "telegram-mcp-bridge",
    version: "1.0.0",
    private: true,
    dependencies: {
      "@modelcontextprotocol/sdk": "^1.12.1",
    },
  };
  fs.writeFileSync(path.join(INSTALL_DIR, "package.json"), JSON.stringify(pkg, null, 2));

  // Deploy server.js (from adjacent file or embedded base64)
  const serverCode = getServerCode();
  if (!serverCode) {
    fail("server.js not found. If using the dev installer, place server.js next to install.js.");
    fail("If using the built installer, the base64 embedding is missing â€” re-run build.js.");
    process.exit(1);
  }
  fs.writeFileSync(path.join(INSTALL_DIR, "server.js"), serverCode);
  ok("Server deployed");

  // npm install
  info("Installing @modelcontextprotocol/sdk (this may take a moment)...");
  try {
    execSync("npm install --production", {
      cwd: INSTALL_DIR,
      stdio: "pipe",
      timeout: 120000,
    });
    ok("Dependencies installed");
  } catch (e) {
    fail("npm install failed: " + (e.stderr?.toString().slice(0, 200) || e.message));
    process.exit(1);
  }

  // â”€â”€ Step 4: Telegram bot setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  step(4, TOTAL, "Telegram Bot setup");
  console.log("");
  console.log(`  ${C.bold}Do you already have a Telegram bot token?${C.reset}`);
  console.log(`    ${C.bold}1)${C.reset} No, I need to create a new bot`);
  console.log(`    ${C.bold}2)${C.reset} Yes, I have a token ready`);
  console.log("");

  const hasToken = (await ask("Enter choice [1-2]: ")).trim();

  if (hasToken !== "2") {
    console.log("");
    console.log(`  ${C.bold}Opening BotFather in Telegram...${C.reset}`);
    info("If it doesn't open, go to: https://t.me/BotFather");
    console.log("");
    openUrl("https://t.me/BotFather");

    console.log(`  ${C.bold}In the BotFather chat:${C.reset}`);
    console.log("");
    console.log(`  ${C.cyan}1.${C.reset} Click ${C.bold}Start${C.reset} (or type /start)`);
    console.log(`  ${C.cyan}2.${C.reset} Type: ${C.bold}/newbot${C.reset}`);
    console.log(`  ${C.cyan}3.${C.reset} Enter any name, e.g.: ${C.bold}Agent Bridge${C.reset}`);
    console.log(`  ${C.cyan}4.${C.reset} Enter a username ending in 'bot', e.g.: ${C.bold}my_agent_bridge_bot${C.reset}`);
    console.log(`  ${C.cyan}5.${C.reset} BotFather gives you a token like: ${C.bold}7123456789:AAHfG3kB3x_example${C.reset}`);
    console.log("");
  }

  // --- Token input (robust: sanitize to avoid paste issues) ---
  console.log("");
  info("Tip: If pasting crashes, save the token to a file and enter the file path instead.");
  console.log("");
  const rawToken = (await ask("Paste your bot token (or path to a file containing it): ")).trim();

  let botToken;
  // Check if user gave a file path
  if (fs.existsSync(rawToken)) {
    botToken = fs.readFileSync(rawToken, "utf-8").trim();
    info("Read token from file");
  } else {
    botToken = rawToken;
  }
  // Sanitize: keep only valid token chars
  botToken = botToken.replace(/[^a-zA-Z0-9:_-]/g, "");

  if (!botToken) {
    fail("Token is empty. Please try again.");
    process.exit(1);
  }

  // Mask for display
  const masked = botToken.length > 10
    ? botToken.slice(0, 4) + "*".repeat(botToken.length - 8) + botToken.slice(-4)
    : botToken.slice(0, 2) + "****" + botToken.slice(-2);
  ok(`Token received: ${masked}`);

  if (!/^\d+:.+$/.test(botToken)) {
    warn("Token format looks unusual (expected 123456:ABC...). Continuing anyway.");
  }

  // --- Verify token ---
  info("Verifying bot token with Telegram...");
  let botUsername = "";
  try {
    const me = await tgApi(botToken, "getMe");
    if (me.ok) {
      const b = me.result;
      ok(`Bot verified: ${b.first_name} (@${b.username})`);
      botUsername = b.username;
    } else {
      warn("Token verification failed: " + JSON.stringify(me));
      const cont = (await ask("Continue anyway? [y/N]: ")).trim().toLowerCase();
      if (cont !== "y") process.exit(1);
    }
  } catch (e) {
    warn("Verification error: " + e.message);
    const cont = (await ask("Continue anyway? [y/N]: ")).trim().toLowerCase();
    if (cont !== "y") process.exit(1);
  }

  // --- Get chat ID (Forum Group setup) ---
  console.log("");
  console.log(`  ${C.bold}Now we need a Telegram group with Topics enabled.${C.reset}`);
  console.log(`  ${C.bold}Each agent session gets its own topic â€” full isolation.${C.reset}`);
  console.log("");
  console.log(`  ${C.bold}Do you already have a forum group set up?${C.reset}`);
  console.log(`    ${C.bold}1)${C.reset} No, help me create one`);
  console.log(`    ${C.bold}2)${C.reset} Yes, I have the group Chat ID ready`);
  console.log("");

  const hasGroup = (await ask("Enter choice [1-2]: ")).trim();

  if (hasGroup !== "2") {
    console.log("");
    console.log(`  ${C.cyan}${C.bold}Follow these steps in Telegram:${C.reset}`);
    console.log("");
    console.log(`  ${C.cyan}1.${C.reset} Open Telegram and tap ${C.bold}New Group${C.reset}`);
    console.log(`  ${C.cyan}2.${C.reset} Add your bot ${C.bold}@${botUsername || "your_bot"}${C.reset} as a member`);
    console.log(`  ${C.cyan}3.${C.reset} Name it something like ${C.bold}Agent Bridge${C.reset} and create it`);
    console.log(`  ${C.cyan}4.${C.reset} Open ${C.bold}Group Settings${C.reset} (tap group name at top)`);
    console.log(`  ${C.cyan}5.${C.reset} Tap ${C.bold}Edit${C.reset} (pencil icon) â†’ scroll down`);
    console.log(`  ${C.cyan}6.${C.reset} Enable ${C.bold}Topics${C.reset} (this converts it to a forum supergroup)`);
    console.log(`  ${C.cyan}7.${C.reset} Go to ${C.bold}Administrators${C.reset} â†’ tap your bot â†’ enable:`);
    console.log(`     â€¢ ${C.bold}Manage Topics${C.reset}`);
    console.log(`     â€¢ ${C.bold}Delete Messages${C.reset} (optional but recommended)`);
    console.log(`  ${C.cyan}8.${C.reset} Send any message in the group (e.g. ${C.bold}hello${C.reset})`);
    console.log("");
    info("The installer will detect the group automatically...");
    console.log("");
  }

  // Flush old updates and track offset
  let detectOffset = 0;
  try {
    const old = await tgApi(botToken, "getUpdates", { offset: -1 });
    if (old.ok && old.result && old.result.length) {
      detectOffset = old.result[old.result.length - 1].update_id + 1;
      await tgApi(botToken, "getUpdates", { offset: detectOffset });
    }
  } catch { /* ignore */ }

  let chatId = "";
  let chatTitle = "";

  if (hasGroup === "2") {
    chatId = (await ask("Enter your group Chat ID (starts with -): ")).trim();
  } else {
    // Poll for new message from the group
    const pollStart = Date.now();
    const pollTimeout = 180000; // 3 minutes

    process.stdout.write(`  ${C.cyan}â³${C.reset} ${C.dim}Waiting for a message in the group...${C.reset}`);

    while (Date.now() - pollStart < pollTimeout) {
      try {
        const res = await tgApi(botToken, "getUpdates", { offset: detectOffset, timeout: 5 });
        if (res.ok && res.result) {
          for (const u of res.result) {
            detectOffset = u.update_id + 1;
            const msg = u.message;
            if (!msg || !msg.chat) continue;
            // Look for supergroup (forum groups are supergroups)
            if (msg.chat.type === "supergroup" || msg.chat.type === "group") {
              chatId = String(msg.chat.id);
              chatTitle = msg.chat.title || "";
              await tgApi(botToken, "getUpdates", { offset: detectOffset });
              break;
            }
          }
        }
        if (chatId) break;
      } catch { /* retry */ }
      process.stdout.write(".");
      await new Promise((r) => setTimeout(r, 2000));
    }
    console.log(""); // newline after dots

    if (!chatId) {
      warn("Auto-detect timed out.");
      console.log("");
      info("Find it manually: open this URL in a browser:");
      info(`https://api.telegram.org/bot${botToken}/getUpdates`);
      info('Look for: "chat":{"id":-100XXXXXXXXXX,"type":"supergroup"}');
      console.log("");
      chatId = (await ask("Enter your group Chat ID: ")).trim();
    }
  }

  if (chatId) {
    ok(`Detected! Chat ID: ${chatId}${chatTitle ? ` (${chatTitle})` : ""}`);
  }

  if (!chatId || !/^-?\d+$/.test(chatId)) {
    fail("Invalid chat ID. Group IDs typically start with -100...");
    process.exit(1);
  }

  // --- Verify it's a forum group (handle migration) ---
  info("Verifying group setup...");
  let isForumGroup = false;
  try {
    let chatInfo = await tgApi(botToken, "getChat", { chat_id: parseInt(chatId, 10) });

    // Handle migration: old group â†’ supergroup
    if (!chatInfo.ok && chatInfo.parameters?.migrate_to_chat_id) {
      const newId = String(chatInfo.parameters.migrate_to_chat_id);
      info(`Group migrated to supergroup: ${chatId} â†’ ${newId}`);
      chatId = newId;
      chatInfo = await tgApi(botToken, "getChat", { chat_id: parseInt(chatId, 10) });
    }

    if (chatInfo.ok && chatInfo.result) {
      const chat = chatInfo.result;
      // Also handle migration via response (some API versions return it differently)
      if (chat.id && String(chat.id) !== chatId) {
        info(`Chat ID updated: ${chatId} â†’ ${chat.id}`);
        chatId = String(chat.id);
      }
      if (chat.is_forum) {
        ok("Forum topics are enabled âœ“");
        isForumGroup = true;
      } else {
        warn("Topics are NOT enabled on this group.");
        console.log("");
        console.log(`  ${C.bold}To enable Topics:${C.reset}`);
        console.log(`  1. Open the group in Telegram`);
        console.log(`  2. Tap the group name â†’ Edit â†’ enable Topics`);
        console.log("");
        const cont = (await ask("Continue anyway? [y/N]: ")).trim().toLowerCase();
        if (cont !== "y") process.exit(1);
      }
    }
  } catch (e) {
    warn("Could not verify group: " + e.message);
  }

  // --- Verify bot is admin with manage_topics ---
  try {
    const me = await tgApi(botToken, "getMe");
    if (me.ok) {
      const member = await tgApi(botToken, "getChatMember", {
        chat_id: parseInt(chatId, 10),
        user_id: me.result.id,
      });
      if (member.ok && member.result) {
        const status = member.result.status;
        if (status === "administrator" || status === "creator") {
          const canManageTopics = member.result.can_manage_topics;
          if (canManageTopics) {
            ok("Bot is admin with Manage Topics permission âœ“");
          } else {
            warn("Bot is admin but missing 'Manage Topics' permission.");
            info("Go to Group Settings â†’ Administrators â†’ your bot â†’ enable Manage Topics");
          }
        } else {
          warn("Bot is not an administrator in this group.");
          info("Go to Group Settings â†’ Administrators â†’ Add your bot as admin");
          info("Enable at least: Manage Topics");
        }
      }
    }
  } catch (e) {
    warn("Could not check bot permissions: " + e.message);
  }

  // --- Send test message ---
  info("Sending test message...");
  try {
    const testRes = await tgApi(botToken, "sendMessage", {
      chat_id: parseInt(chatId, 10),
      text: "ğŸ”— *Telegram MCP Bridge installed!*\n\nEach agent session will create its own topic here.\nChat ID: `" + chatId + "`",
      parse_mode: "Markdown",
    });
    if (testRes.ok) ok("Test message sent â€” check your Telegram group!");
    else warn("Test message failed, continuing.");
  } catch {
    try {
      await tgApi(botToken, "sendMessage", {
        chat_id: parseInt(chatId, 10),
        text: "Telegram MCP Bridge installed! Each agent session will create its own topic here. Chat ID: " + chatId,
      });
      ok("Test message sent (plain text)");
    } catch {
      warn("Test message failed. Make sure the bot is in the group and is an admin.");
    }
  }

  // â”€â”€ Step 5: Write agent prompt â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  step(5, TOTAL, "Writing agent instructions");

  const agentPrompt = `# Telegram Bridge â€” Agent Instructions

You have access to a Telegram MCP bridge for async communication with the user.
Each session has its own topic in a Telegram forum group â€” your messages are isolated.

## Tool: \`interact\`
Single unified tool for all communication:
- \`interact({message: "text"})\` â€” Send a message
- \`interact({})\` â€” Check for new messages
- \`interact({wait: 120})\` â€” Wait up to 120s for a reply
- \`interact({message: "text", wait: 60, since_ts: N})\` â€” Send + wait + filter stale

Response: \`{ok, sent?, messages: [{text, ts}], pending, now}\`
Pass \`now\` as \`since_ts\` on next call to only get newer messages.

## Protocol
1. **Start**: \`interact\` with a greeting and plan summary.
2. **During work**: \`interact\` periodically (every few minutes) to check for input.
3. **Need input**: \`interact\` with your question + \`wait: 120\`.
4. **Done**: \`interact\` with a final summary + \`wait: 120\`.

## Tips
- Keep messages concise (phone-readable).
- Use \`since_ts\` to avoid reading stale messages from before your question.
- Batch updates â€” don't spam multiple messages.
`;
  fs.writeFileSync(path.join(INSTALL_DIR, "AGENT_PROMPT.md"), agentPrompt);
  ok(`Agent prompt saved to ${path.join(INSTALL_DIR, "AGENT_PROMPT.md")}`);

  // Write uninstall script
  if (IS_WIN) {
    fs.writeFileSync(path.join(INSTALL_DIR, "uninstall.bat"),
      `@echo off\r\necho Removing Telegram MCP Bridge...\r\nrd /s /q "%USERPROFILE%\\.telegram-mcp-bridge"\r\ndel /f "%USERPROFILE%\\.telegram_mcp_queue.json" 2>nul\r\necho Done! Remember to remove "telegram-bridge" from your agent's MCP config.\r\npause\r\n`
    );
  } else {
    fs.writeFileSync(path.join(INSTALL_DIR, "uninstall.sh"),
      `#!/bin/bash\necho "Removing Telegram MCP Bridge..."\nrm -rf "${os.homedir()}/.telegram-mcp-bridge"\nrm -f "${os.homedir()}/.telegram_mcp_queue.json"\necho "Done! Remember to remove \\"telegram-bridge\\" from your agent's MCP config."\n`
    );
    try { fs.chmodSync(path.join(INSTALL_DIR, "uninstall.sh"), 0o755); } catch { /* ok */ }
  }

  // â”€â”€ Step 6: Configure agent â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  step(6, TOTAL, `Configuring ${agent.name}`);

  const serverPath = path.join(INSTALL_DIR, "server.js");
  const entry = makeServerEntry(serverPath, botToken, chatId);
  const configPath = agent.configPath();

  if (configPath === "__vscode__") {
    console.log("");
    console.log(`  ${C.yellow}VS Code uses workspace-level MCP config.${C.reset}`);
    console.log(`  Create ${C.bold}.vscode/mcp.json${C.reset} in your project with:`);
    console.log("");
    console.log(JSON.stringify({ servers: { "telegram-bridge": { type: "stdio", ...entry } } }, null, 2)
      .split("\n").map((l) => "  " + l).join("\n"));
    console.log("");
    ok("Copy the JSON above into .vscode/mcp.json");
  } else if (configPath === "__manual__") {
    console.log("");
    console.log(`  ${C.bold}Add this to your agent's MCP config:${C.reset}`);
    console.log("");
    console.log(JSON.stringify({ "telegram-bridge": entry }, null, 2)
      .split("\n").map((l) => "  " + l).join("\n"));
    console.log("");
    ok("Copy the JSON above into your config");
  } else {
    try {
      injectConfig(configPath, agent.key, entry);
      ok(`Config written to ${configPath}`);
    } catch (e) {
      fail(`Auto-config failed: ${e.message}`);
      console.log("");
      console.log(`  ${C.bold}Add this manually to ${configPath}:${C.reset}`);
      console.log(JSON.stringify({ "telegram-bridge": entry }, null, 2)
        .split("\n").map((l) => "  " + l).join("\n"));
    }
  }

  // â”€â”€ Done! â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  console.log("");
  console.log(`${C.green}${C.bold}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C.reset}`);
  console.log(`${C.green}${C.bold}â•‘           âœ… Installation complete!              â•‘${C.reset}`);
  console.log(`${C.green}${C.bold}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C.reset}`);
  console.log("");
  console.log(`  ${C.bold}Server:${C.reset}       ${serverPath}`);
  console.log(`  ${C.bold}Agent:${C.reset}        ${agent.name}`);
  if (configPath !== "__vscode__" && configPath !== "__manual__") {
    console.log(`  ${C.bold}Config:${C.reset}       ${configPath}`);
  }
  console.log(`  ${C.bold}Bot:${C.reset}          @${botUsername || "unknown"}`);
  console.log(`  ${C.bold}Chat ID:${C.reset}      ${chatId}`);
  console.log(`  ${C.bold}Mode:${C.reset}         Forum Topics (per-session isolation)`);
  console.log("");
  console.log(`  ${C.bold}Next steps:${C.reset}`);
  info("1. Restart your agent / IDE to load the new MCP server");
  info(`2. Add the contents of ${path.join(INSTALL_DIR, "AGENT_PROMPT.md")}`);
  info("   to your system prompt (CLAUDE.md / GEMINI.md / .cursorrules / rules)");
  info("3. Ask your agent to send you a Telegram message!");
  info("   â†’ It will auto-create a topic in your forum group");
  console.log("");
  if (IS_WIN) {
    console.log(`  ${C.bold}Uninstall:${C.reset}  ${C.dim}${path.join(INSTALL_DIR, "uninstall.bat")}${C.reset}`);
  } else {
    console.log(`  ${C.bold}Uninstall:${C.reset}  ${C.dim}${path.join(INSTALL_DIR, "uninstall.sh")}${C.reset}`);
  }
  console.log("");

  rl.close();
}

main().catch((e) => {
  console.error(`\n${C.red}Fatal error:${C.reset} ${e.message}`);
  process.exit(1);
});
