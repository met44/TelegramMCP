#!/usr/bin/env node
// =============================================================================
//  Telegram MCP Bridge â€” One-File Installer
//  Run: node install.js
//  Works on Windows, macOS, Linux. Requires Node.js 18+.
// =============================================================================

const readline = require("readline");
const https = require("https");
const fs = require("fs");
const path = require("path");
const os = require("os");
const { execSync } = require("child_process");

// ---------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------
const INSTALL_DIR = path.join(os.homedir(), ".telegram-mcp-bridge");
const IS_WIN = process.platform === "win32";
const IS_MAC = process.platform === "darwin";

// ---------------------------------------------------------------------------
// Colors (ANSI)
// ---------------------------------------------------------------------------
const C = {
  reset: "\x1b[0m", bold: "\x1b[1m", dim: "\x1b[2m",
  red: "\x1b[31m", green: "\x1b[32m", yellow: "\x1b[33m",
  blue: "\x1b[34m", cyan: "\x1b[36m",
};
const ok = (s) => console.log(`  ${C.green}âœ”${C.reset} ${s}`);
const warn = (s) => console.log(`  ${C.yellow}âš ${C.reset} ${s}`);
const fail = (s) => console.log(`  ${C.red}âœ˜${C.reset} ${s}`);
const info = (s) => console.log(`  ${C.dim}${s}${C.reset}`);
const step = (n, total, s) => console.log(`\n${C.blue}${C.bold}[${n}/${total}]${C.reset} ${C.bold}${s}${C.reset}`);

// ---------------------------------------------------------------------------
// Readline helper
// ---------------------------------------------------------------------------
const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
const ask = (q) => new Promise((res) => rl.question(`  ${C.cyan}â–¸${C.reset} ${q}`, res));

// ---------------------------------------------------------------------------
// HTTP helpers
// ---------------------------------------------------------------------------
function httpGet(url) {
  return new Promise((resolve, reject) => {
    https.get(url, { timeout: 15000 }, (res) => {
      let data = "";
      res.on("data", (c) => (data += c));
      res.on("end", () => resolve(data));
    }).on("error", reject).on("timeout", function () { this.destroy(); reject(new Error("timeout")); });
  });
}

function httpPost(url, body) {
  return new Promise((resolve, reject) => {
    const payload = JSON.stringify(body);
    const u = new URL(url);
    const opts = {
      hostname: u.hostname, path: u.pathname, method: "POST", timeout: 15000,
      headers: { "Content-Type": "application/json", "Content-Length": Buffer.byteLength(payload) },
    };
    const req = https.request(opts, (res) => {
      let data = "";
      res.on("data", (c) => (data += c));
      res.on("end", () => resolve(data));
    });
    req.on("error", reject);
    req.on("timeout", () => { req.destroy(); reject(new Error("timeout")); });
    req.write(payload);
    req.end();
  });
}

function tgApi(token, method, body) {
  const url = `https://api.telegram.org/bot${token}/${method}`;
  return body ? httpPost(url, body).then(JSON.parse) : httpGet(url).then(JSON.parse);
}

// ---------------------------------------------------------------------------
// Open URL cross-platform
// ---------------------------------------------------------------------------
function openUrl(url) {
  try {
    if (IS_WIN) execSync(`start "" "${url}"`, { stdio: "ignore", shell: true });
    else if (IS_MAC) execSync(`open "${url}"`, { stdio: "ignore" });
    else execSync(`xdg-open "${url}" 2>/dev/null || sensible-browser "${url}" 2>/dev/null`, { stdio: "ignore", shell: true });
  } catch { /* ignore */ }
}

// ---------------------------------------------------------------------------
// Agent definitions
// ---------------------------------------------------------------------------
const AGENTS = [
  { id: 1, name: "Claude Code", configPath: () => path.join(os.homedir(), ".claude.json"), key: "mcpServers" },
  {
    id: 2, name: "Claude Desktop", key: "mcpServers",
    configPath: () => {
      if (IS_WIN) return path.join(process.env.APPDATA || path.join(os.homedir(), "AppData", "Roaming"), "Claude", "claude_desktop_config.json");
      if (IS_MAC) return path.join(os.homedir(), "Library", "Application Support", "Claude", "claude_desktop_config.json");
      return path.join(os.homedir(), ".config", "Claude", "claude_desktop_config.json");
    },
  },
  { id: 3, name: "Cursor", configPath: () => path.join(os.homedir(), ".cursor", "mcp.json"), key: "mcpServers" },
  { id: 4, name: "Windsurf", configPath: () => path.join(os.homedir(), ".codeium", "windsurf", "mcp_config.json"), key: "mcpServers" },
  {
    id: 5, name: "VS Code (Copilot)", configPath: () => "__vscode__", key: "servers",
  },
  { id: 6, name: "Gemini CLI", configPath: () => path.join(os.homedir(), ".gemini", "settings.json"), key: "mcpServers" },
  { id: 7, name: "Cline", configPath: () => path.join(os.homedir(), ".cline", "mcp_config.json"), key: "mcpServers" },
  { id: 8, name: "Other / Manual", configPath: () => "__manual__", key: "mcpServers" },
];

// ---------------------------------------------------------------------------
// Server entry JSON for config injection
// ---------------------------------------------------------------------------
function makeServerEntry(serverPath, botToken, chatId) {
  // Normalize to forward slashes for JSON config (Node handles both on Windows)
  const normalizedPath = serverPath.replace(/\\/g, "/");
  return {
    command: "node",
    args: [normalizedPath],
    env: {
      TELEGRAM_BOT_TOKEN: botToken,
      TELEGRAM_CHAT_ID: chatId,
    },
  };
}

// ---------------------------------------------------------------------------
// Config injection
// ---------------------------------------------------------------------------
function injectConfig(configPath, key, entry) {
  let config = {};
  if (fs.existsSync(configPath)) {
    try {
      config = JSON.parse(fs.readFileSync(configPath, "utf-8"));
    } catch {
      config = {};
    }
    // Backup
    const bak = configPath + ".bak." + Date.now();
    fs.copyFileSync(configPath, bak);
    info(`Backed up to ${path.basename(bak)}`);
  }
  fs.mkdirSync(path.dirname(configPath), { recursive: true });
  if (!config[key]) config[key] = {};
  config[key]["telegram-bridge"] = entry;
  fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
}

// ---------------------------------------------------------------------------
// Embedded server.js as base64 (injected by build.js, or read from adjacent file)
// ---------------------------------------------------------------------------
const SERVER_B64 = "IyEvdXNyL2Jpbi9lbnYgbm9kZQ0KLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0NCi8vICBUZWxlZ3JhbSBNQ1AgQnJpZGdlIFNlcnZlciB2Mg0KLy8gIEJyaWRnZXMgQUkgYWdlbnQgc2Vzc2lvbnMgd2l0aCBhIGh1bWFuIHZpYSBUZWxlZ3JhbSBGb3J1bSBUb3BpY3MuDQovLyAgRWFjaCBzZXNzaW9uIGdldHMgaXRzIG93biB0b3BpYyDigJQgZnVsbCBwZXItYWdlbnQgaXNvbGF0aW9uLg0KLy8gIFNpbmdsZSB1bmlmaWVkIHRvb2w6IGludGVyYWN0DQovLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQ0KDQpjb25zdCB7IFNlcnZlciB9ID0gcmVxdWlyZSgiQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zZXJ2ZXIvaW5kZXguanMiKTsNCmNvbnN0IHsgU3RkaW9TZXJ2ZXJUcmFuc3BvcnQgfSA9IHJlcXVpcmUoIkBtb2RlbGNvbnRleHRwcm90b2NvbC9zZGsvc2VydmVyL3N0ZGlvLmpzIik7DQpjb25zdCB7DQogIENhbGxUb29sUmVxdWVzdFNjaGVtYSwNCiAgTGlzdFRvb2xzUmVxdWVzdFNjaGVtYSwNCn0gPSByZXF1aXJlKCJAbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3R5cGVzLmpzIik7DQpjb25zdCBodHRwcyA9IHJlcXVpcmUoImh0dHBzIik7DQpjb25zdCBmcyA9IHJlcXVpcmUoImZzIik7DQpjb25zdCBwYXRoID0gcmVxdWlyZSgicGF0aCIpOw0KY29uc3Qgb3MgPSByZXF1aXJlKCJvcyIpOw0KY29uc3QgY3J5cHRvID0gcmVxdWlyZSgiY3J5cHRvIik7DQoNCi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KLy8gQ29uZmlnIGZyb20gZW52DQovLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCmNvbnN0IEJPVF9UT0tFTiA9IHByb2Nlc3MuZW52LlRFTEVHUkFNX0JPVF9UT0tFTiB8fCAiIjsNCmxldCBDSEFUX0lEID0gcHJvY2Vzcy5lbnYuVEVMRUdSQU1fQ0hBVF9JRCB8fCAiIjsNCmNvbnN0IERBVEFfRElSID0gcHJvY2Vzcy5lbnYuVEVMRUdSQU1fTUNQX0RBVEFfRElSIHx8DQogIHBhdGguam9pbihvcy5ob21lZGlyKCksICIudGVsZWdyYW0tbWNwLWJyaWRnZSIsICJkYXRhIik7DQpjb25zdCBNQVhfSElTVE9SWSA9IHBhcnNlSW50KHByb2Nlc3MuZW52LlRFTEVHUkFNX01DUF9NQVhfSElTVE9SWSB8fCAiMjAwIiwgMTApOw0KY29uc3QgUE9MTF9JTlRFUlZBTF9NUyA9IHBhcnNlSW50KHByb2Nlc3MuZW52LlRFTEVHUkFNX1BPTExfSU5URVJWQUwgfHwgIjIwMDAiLCAxMCk7DQoNCi8vIFNlc3Npb24gaWRlbnRpdHkg4oCUIGVhY2ggTUNQIHNlcnZlciBpbnN0YW5jZSBpcyBvbmUgc2Vzc2lvbg0KY29uc3QgU0VTU0lPTl9JRCA9IHByb2Nlc3MuZW52LlRFTEVHUkFNX1NFU1NJT05fSUQgfHwNCiAgYHMtJHtjcnlwdG8ucmFuZG9tQnl0ZXMoMykudG9TdHJpbmcoImhleCIpfWA7DQpjb25zdCBNQUNISU5FX0xBQkVMID0gcHJvY2Vzcy5lbnYuVEVMRUdSQU1fTUFDSElORV9MQUJFTCB8fA0KICBvcy5ob3N0bmFtZSgpLnNsaWNlKDAsIDIwKTsNCmNvbnN0IEFHRU5UX0xBQkVMID0gcHJvY2Vzcy5lbnYuVEVMRUdSQU1fQUdFTlRfTEFCRUwgfHwgImFnZW50IjsNCmNvbnN0IFNFU1NJT05fTEFCRUwgPSBgJHtNQUNISU5FX0xBQkVMfS8ke0FHRU5UX0xBQkVMfWA7DQoNCi8vIEJlaGF2aW9yIGZsYWdzIChzZXQgaW4gTUNQIGNvbmZpZyBlbnYgYmxvY2spDQpjb25zdCBBVVRPX1NFTkRfU1RBUlQgPSBwcm9jZXNzLmVudi5URUxFR1JBTV9BVVRPX1NUQVJUICE9PSAiZmFsc2UiOw0KY29uc3QgQVVUT19TRU5EX0VORCA9IHByb2Nlc3MuZW52LlRFTEVHUkFNX0FVVE9fRU5EICE9PSAiZmFsc2UiOw0KY29uc3QgQVVUT19TVU1NQVJZID0gcHJvY2Vzcy5lbnYuVEVMRUdSQU1fQVVUT19TVU1NQVJZICE9PSAiZmFsc2UiOw0KY29uc3QgQVVUT19QT0xMID0gcHJvY2Vzcy5lbnYuVEVMRUdSQU1fQVVUT19QT0xMICE9PSAiZmFsc2UiOw0KDQovLyBMZWdhY3kgY29tcGF0OiBvbGQgUVVFVUVfRklMRSBlbnYgc3RpbGwgd29ya3MgZm9yIHNpbmdsZS1zZXNzaW9uIHNldHVwcw0KY29uc3QgTEVHQUNZX1FVRVVFX0ZJTEUgPSBwcm9jZXNzLmVudi5URUxFR1JBTV9NQ1BfUVVFVUVfRklMRSB8fCAiIjsNCg0KLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQovLyBMb2dnaW5nIChzdGRlcnIgb25seSDigJQgc3Rkb3V0IGlzIE1DUCBzdGRpbyB0cmFuc3BvcnQpDQovLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCmNvbnN0IGxvZyA9IHsNCiAgaW5mbzogKC4uLmEpID0+IHByb2Nlc3Muc3RkZXJyLndyaXRlKGBbSU5GT10gJHthLmpvaW4oIiAiKX1cbmApLA0KICB3YXJuOiAoLi4uYSkgPT4gcHJvY2Vzcy5zdGRlcnIud3JpdGUoYFtXQVJOXSAke2Euam9pbigiICIpfVxuYCksDQogIGVycm9yOiAoLi4uYSkgPT4gcHJvY2Vzcy5zdGRlcnIud3JpdGUoYFtFUlJPUl0gJHthLmpvaW4oIiAiKX1cbmApLA0KfTsNCg0KLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQovLyBUZWxlZ3JhbSBIVFRQIGhlbHBlcnMgKHplcm8gZGVwZW5kZW5jaWVzIOKAlCB1c2VzIGJ1aWx0LWluIGh0dHBzKQ0KLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQpmdW5jdGlvbiB0Z0FwaShtZXRob2QsIGJvZHkpIHsNCiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHsNCiAgICBjb25zdCBwYXlsb2FkID0gYm9keSA/IEpTT04uc3RyaW5naWZ5KGJvZHkpIDogbnVsbDsNCiAgICBjb25zdCBvcHRzID0gew0KICAgICAgaG9zdG5hbWU6ICJhcGkudGVsZWdyYW0ub3JnIiwNCiAgICAgIHBhdGg6IGAvYm90JHtCT1RfVE9LRU59LyR7bWV0aG9kfWAsDQogICAgICBtZXRob2Q6IHBheWxvYWQgPyAiUE9TVCIgOiAiR0VUIiwNCiAgICAgIGhlYWRlcnM6IHBheWxvYWQNCiAgICAgICAgPyB7ICJDb250ZW50LVR5cGUiOiAiYXBwbGljYXRpb24vanNvbiIsICJDb250ZW50LUxlbmd0aCI6IEJ1ZmZlci5ieXRlTGVuZ3RoKHBheWxvYWQpIH0NCiAgICAgICAgOiB7fSwNCiAgICAgIHRpbWVvdXQ6IDMwMDAwLA0KICAgIH07DQogICAgY29uc3QgcmVxID0gaHR0cHMucmVxdWVzdChvcHRzLCAocmVzKSA9PiB7DQogICAgICBsZXQgZGF0YSA9ICIiOw0KICAgICAgcmVzLm9uKCJkYXRhIiwgKGMpID0+IChkYXRhICs9IGMpKTsNCiAgICAgIHJlcy5vbigiZW5kIiwgKCkgPT4gew0KICAgICAgICB0cnkgew0KICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKGRhdGEpOw0KICAgICAgICAgIHJlc29sdmUoanNvbik7DQogICAgICAgIH0gY2F0Y2ggew0KICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEludmFsaWQgSlNPTiBmcm9tIFRlbGVncmFtOiAke2RhdGEuc2xpY2UoMCwgMjAwKX1gKSk7DQogICAgICAgIH0NCiAgICAgIH0pOw0KICAgIH0pOw0KICAgIHJlcS5vbigiZXJyb3IiLCByZWplY3QpOw0KICAgIHJlcS5vbigidGltZW91dCIsICgpID0+IHsgcmVxLmRlc3Ryb3koKTsgcmVqZWN0KG5ldyBFcnJvcigiVGVsZWdyYW0gQVBJIHRpbWVvdXQiKSk7IH0pOw0KICAgIGlmIChwYXlsb2FkKSByZXEud3JpdGUocGF5bG9hZCk7DQogICAgcmVxLmVuZCgpOw0KICB9KTsNCn0NCg0KLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQovLyBUb3BpYyBtYW5hZ2VtZW50IOKAlCBlYWNoIHNlc3Npb24gZ2V0cyBpdHMgb3duIGZvcnVtIHRvcGljDQovLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCmxldCB0b3BpY0lkID0gbnVsbDsgLy8gbWVzc2FnZV90aHJlYWRfaWQgZm9yIHRoaXMgc2Vzc2lvbidzIHRvcGljDQoNCi8vIFBlcnNpc3RlZCB0b3BpYyBtYXA6IHsgc2Vzc2lvbkxhYmVsOiB0b3BpY0lkIH0NCmZ1bmN0aW9uIGdldFRvcGljTWFwRmlsZSgpIHsgcmV0dXJuIHBhdGguam9pbihEQVRBX0RJUiwgIl90b3BpY3MuanNvbiIpOyB9DQoNCmZ1bmN0aW9uIGxvYWRUb3BpY01hcCgpIHsNCiAgdHJ5IHsNCiAgICBpZiAoZnMuZXhpc3RzU3luYyhnZXRUb3BpY01hcEZpbGUoKSkpIHsNCiAgICAgIHJldHVybiBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhnZXRUb3BpY01hcEZpbGUoKSwgInV0Zi04IikpOw0KICAgIH0NCiAgfSBjYXRjaCB7IC8qIG9rICovIH0NCiAgcmV0dXJuIHt9Ow0KfQ0KDQpmdW5jdGlvbiBzYXZlVG9waWNNYXAobWFwKSB7DQogIHRyeSB7DQogICAgZnMubWtkaXJTeW5jKERBVEFfRElSLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTsNCiAgICBmcy53cml0ZUZpbGVTeW5jKGdldFRvcGljTWFwRmlsZSgpLCBKU09OLnN0cmluZ2lmeShtYXAsIG51bGwsIDIpKTsNCiAgfSBjYXRjaCAoZSkgew0KICAgIGxvZy53YXJuKCJUb3BpYyBtYXAgc2F2ZSBmYWlsZWQ6IiwgZS5tZXNzYWdlKTsNCiAgfQ0KfQ0KDQphc3luYyBmdW5jdGlvbiBlbnN1cmVUb3BpYygpIHsNCiAgaWYgKCFCT1RfVE9LRU4gfHwgIUNIQVRfSUQpIHJldHVybiBudWxsOw0KDQogIC8vIENoZWNrIGlmIHdlIGFscmVhZHkgaGF2ZSBhIHRvcGljIGZvciB0aGlzIHNlc3Npb24gbGFiZWwNCiAgY29uc3QgbWFwID0gbG9hZFRvcGljTWFwKCk7DQogIGlmIChtYXBbU0VTU0lPTl9MQUJFTF0pIHsNCiAgICB0b3BpY0lkID0gbWFwW1NFU1NJT05fTEFCRUxdOw0KICAgIGxvZy5pbmZvKGBSZXVzaW5nIHRvcGljICR7dG9waWNJZH0gZm9yICR7U0VTU0lPTl9MQUJFTH1gKTsNCiAgICByZXR1cm4gdG9waWNJZDsNCiAgfQ0KDQogIC8vIENyZWF0ZSBhIG5ldyB0b3BpYw0KICB0cnkgew0KICAgIGxldCBjaGF0SWROdW0gPSBwYXJzZUludChDSEFUX0lELCAxMCk7DQogICAgbGV0IHJlcyA9IGF3YWl0IHRnQXBpKCJjcmVhdGVGb3J1bVRvcGljIiwgew0KICAgICAgY2hhdF9pZDogY2hhdElkTnVtLA0KICAgICAgbmFtZTogYPCfpJYgJHtTRVNTSU9OX0xBQkVMfWAsDQogICAgfSk7DQoNCiAgICAvLyBIYW5kbGUgY2hhdCBtaWdyYXRpb24gKGdyb3VwIHVwZ3JhZGVkIHRvIHN1cGVyZ3JvdXApDQogICAgaWYgKCFyZXMub2sgJiYgcmVzLnBhcmFtZXRlcnM/Lm1pZ3JhdGVfdG9fY2hhdF9pZCkgew0KICAgICAgY29uc3QgbmV3SWQgPSBTdHJpbmcocmVzLnBhcmFtZXRlcnMubWlncmF0ZV90b19jaGF0X2lkKTsNCiAgICAgIGxvZy5pbmZvKGBDaGF0IG1pZ3JhdGVkOiAke0NIQVRfSUR9IOKGkiAke25ld0lkfWApOw0KICAgICAgQ0hBVF9JRCA9IG5ld0lkOw0KICAgICAgY2hhdElkTnVtID0gcGFyc2VJbnQoQ0hBVF9JRCwgMTApOw0KICAgICAgcmVzID0gYXdhaXQgdGdBcGkoImNyZWF0ZUZvcnVtVG9waWMiLCB7DQogICAgICAgIGNoYXRfaWQ6IGNoYXRJZE51bSwNCiAgICAgICAgbmFtZTogYPCfpJYgJHtTRVNTSU9OX0xBQkVMfWAsDQogICAgICB9KTsNCiAgICB9DQoNCiAgICBpZiAocmVzLm9rICYmIHJlcy5yZXN1bHQpIHsNCiAgICAgIHRvcGljSWQgPSByZXMucmVzdWx0Lm1lc3NhZ2VfdGhyZWFkX2lkOw0KICAgICAgbWFwW1NFU1NJT05fTEFCRUxdID0gdG9waWNJZDsNCiAgICAgIHNhdmVUb3BpY01hcChtYXApOw0KICAgICAgbG9nLmluZm8oYENyZWF0ZWQgdG9waWMgJHt0b3BpY0lkfSBmb3IgJHtTRVNTSU9OX0xBQkVMfWApOw0KICAgICAgcmV0dXJuIHRvcGljSWQ7DQogICAgfQ0KICAgIGxvZy53YXJuKCJjcmVhdGVGb3J1bVRvcGljIGZhaWxlZDoiLCBKU09OLnN0cmluZ2lmeShyZXMpKTsNCiAgfSBjYXRjaCAoZSkgew0KICAgIGxvZy53YXJuKCJjcmVhdGVGb3J1bVRvcGljIGVycm9yOiIsIGUubWVzc2FnZSk7DQogIH0NCg0KICAvLyBGYWxsYmFjazogbm8gdG9waWMgKHNlbmQgdG8gR2VuZXJhbCkNCiAgcmV0dXJuIG51bGw7DQp9DQoNCi8vIEJ1aWxkIHJldmVyc2UgbWFwOiB0b3BpY0lkIOKGkiBzZXNzaW9uTGFiZWwgKGZvciByb3V0aW5nIGluY29taW5nIG1lc3NhZ2VzKQ0KZnVuY3Rpb24gYnVpbGRUb3BpY1RvU2Vzc2lvbk1hcCgpIHsNCiAgY29uc3QgbWFwID0gbG9hZFRvcGljTWFwKCk7DQogIGNvbnN0IHJldmVyc2UgPSB7fTsNCiAgZm9yIChjb25zdCBbbGFiZWwsIHRpZF0gb2YgT2JqZWN0LmVudHJpZXMobWFwKSkgew0KICAgIHJldmVyc2VbU3RyaW5nKHRpZCldID0gbGFiZWw7DQogIH0NCiAgcmV0dXJuIHJldmVyc2U7DQp9DQoNCi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KLy8gU2VuZCBtZXNzYWdlIHRvIHRoaXMgc2Vzc2lvbidzIHRvcGljIChvciBHZW5lcmFsIGFzIGZhbGxiYWNrKQ0KLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQphc3luYyBmdW5jdGlvbiBzZW5kVG9Ub3BpYyh0ZXh0KSB7DQogIGlmICghQk9UX1RPS0VOIHx8ICFDSEFUX0lEKSByZXR1cm4gZmFsc2U7DQogIGNvbnN0IGJvZHkgPSB7DQogICAgY2hhdF9pZDogcGFyc2VJbnQoQ0hBVF9JRCwgMTApLA0KICAgIHRleHQsDQogICAgcGFyc2VfbW9kZTogIk1hcmtkb3duIiwNCiAgfTsNCiAgaWYgKHRvcGljSWQpIGJvZHkubWVzc2FnZV90aHJlYWRfaWQgPSB0b3BpY0lkOw0KICB0cnkgew0KICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRnQXBpKCJzZW5kTWVzc2FnZSIsIGJvZHkpOw0KICAgIGlmIChyZXMub2spIHJldHVybiB0cnVlOw0KICAgIC8vIE1hcmtkb3duIHBhcnNlIGVycm9yIOKAlCByZXRyeSBwbGFpbg0KICAgIGRlbGV0ZSBib2R5LnBhcnNlX21vZGU7DQogICAgY29uc3QgcmVzMiA9IGF3YWl0IHRnQXBpKCJzZW5kTWVzc2FnZSIsIGJvZHkpOw0KICAgIHJldHVybiAhIXJlczIub2s7DQogIH0gY2F0Y2ggKGUpIHsNCiAgICBsb2cuZXJyb3IoInNlbmRNZXNzYWdlIGZhaWxlZDoiLCBlLm1lc3NhZ2UpOw0KICAgIHJldHVybiBmYWxzZTsNCiAgfQ0KfQ0KDQovLyBTZW5kIHRvIEdlbmVyYWwgdG9waWMgKG5vIG1lc3NhZ2VfdGhyZWFkX2lkKQ0KYXN5bmMgZnVuY3Rpb24gc2VuZFRvR2VuZXJhbCh0ZXh0KSB7DQogIGlmICghQk9UX1RPS0VOIHx8ICFDSEFUX0lEKSByZXR1cm4gZmFsc2U7DQogIHRyeSB7DQogICAgY29uc3QgcmVzID0gYXdhaXQgdGdBcGkoInNlbmRNZXNzYWdlIiwgew0KICAgICAgY2hhdF9pZDogcGFyc2VJbnQoQ0hBVF9JRCwgMTApLA0KICAgICAgdGV4dCwNCiAgICAgIHBhcnNlX21vZGU6ICJNYXJrZG93biIsDQogICAgfSk7DQogICAgaWYgKHJlcy5vaykgcmV0dXJuIHRydWU7DQogICAgY29uc3QgcmVzMiA9IGF3YWl0IHRnQXBpKCJzZW5kTWVzc2FnZSIsIHsNCiAgICAgIGNoYXRfaWQ6IHBhcnNlSW50KENIQVRfSUQsIDEwKSwNCiAgICAgIHRleHQsDQogICAgfSk7DQogICAgcmV0dXJuICEhcmVzMi5vazsNCiAgfSBjYXRjaCAoZSkgew0KICAgIGxvZy5lcnJvcigic2VuZFRvR2VuZXJhbCBmYWlsZWQ6IiwgZS5tZXNzYWdlKTsNCiAgICByZXR1cm4gZmFsc2U7DQogIH0NCn0NCg0KLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQovLyBNZXNzYWdlIHF1ZXVlIOKAlCBwZXJzaXN0ZWQgdG8gZGlzaywgbWluaW1hbCBtZW1vcnkgZm9vdHByaW50DQovLyBFYWNoIHNlc3Npb24gaGFzIGl0cyBvd24gcXVldWUuIE1lc3NhZ2VzIHJvdXRlZCBieSB0b3BpYy4NCi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KY2xhc3MgTWVzc2FnZVF1ZXVlIHsNCiAgY29uc3RydWN0b3IoZmlsZVBhdGgpIHsNCiAgICB0aGlzLl9maWxlID0gZmlsZVBhdGg7DQogICAgdGhpcy5fcGVuZGluZyA9IFtdOw0KICAgIHRoaXMuX2RlbGl2ZXJlZCA9IFtdOw0KICAgIHRoaXMuX2xvYWQoKTsNCiAgfQ0KDQogIF9sb2FkKCkgew0KICAgIHRyeSB7DQogICAgICBpZiAoZnMuZXhpc3RzU3luYyh0aGlzLl9maWxlKSkgew0KICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmModGhpcy5fZmlsZSwgInV0Zi04IikpOw0KICAgICAgICB0aGlzLl9wZW5kaW5nID0gZGF0YS5wZW5kaW5nIHx8IFtdOw0KICAgICAgICB0aGlzLl9kZWxpdmVyZWQgPSAoZGF0YS5kZWxpdmVyZWQgfHwgW10pLnNsaWNlKC1NQVhfSElTVE9SWSk7DQogICAgICB9DQogICAgfSBjYXRjaCAoZSkgew0KICAgICAgbG9nLndhcm4oIlF1ZXVlIGxvYWQgZmFpbGVkOiIsIGUubWVzc2FnZSk7DQogICAgfQ0KICB9DQoNCiAgX3NhdmUoKSB7DQogICAgdHJ5IHsNCiAgICAgIGZzLm1rZGlyU3luYyhwYXRoLmRpcm5hbWUodGhpcy5fZmlsZSksIHsgcmVjdXJzaXZlOiB0cnVlIH0pOw0KICAgICAgZnMud3JpdGVGaWxlU3luYyh0aGlzLl9maWxlLCBKU09OLnN0cmluZ2lmeSh7DQogICAgICAgIHBlbmRpbmc6IHRoaXMuX3BlbmRpbmcsDQogICAgICAgIGRlbGl2ZXJlZDogdGhpcy5fZGVsaXZlcmVkLnNsaWNlKC1NQVhfSElTVE9SWSksDQogICAgICB9LCBudWxsLCAyKSk7DQogICAgfSBjYXRjaCAoZSkgew0KICAgICAgbG9nLndhcm4oIlF1ZXVlIHNhdmUgZmFpbGVkOiIsIGUubWVzc2FnZSk7DQogICAgfQ0KICB9DQoNCiAgZW5xdWV1ZSh0ZXh0LCBzZW5kZXIgPSAidXNlciIpIHsNCiAgICBjb25zdCBtc2cgPSB7DQogICAgICBpZDogY3J5cHRvLnJhbmRvbUJ5dGVzKDQpLnRvU3RyaW5nKCJoZXgiKSwNCiAgICAgIHRleHQsDQogICAgICBzZW5kZXIsDQogICAgICB0czogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksDQogICAgfTsNCiAgICB0aGlzLl9wZW5kaW5nLnB1c2gobXNnKTsNCiAgICB0aGlzLl9zYXZlKCk7DQogICAgcmV0dXJuIG1zZzsNCiAgfQ0KDQogIHBvbGwoKSB7DQogICAgaWYgKCF0aGlzLl9wZW5kaW5nLmxlbmd0aCkgcmV0dXJuIFtdOw0KICAgIGNvbnN0IG1zZ3MgPSB0aGlzLl9wZW5kaW5nLnNwbGljZSgwKTsNCiAgICB0aGlzLl9kZWxpdmVyZWQucHVzaCguLi5tc2dzKTsNCiAgICB0aGlzLl9zYXZlKCk7DQogICAgcmV0dXJuIG1zZ3M7DQogIH0NCg0KICAvLyBQb2xsIG9ubHkgbWVzc2FnZXMgd2l0aCB0cyA+IHNpbmNlVHMgKGZvciB0aW1lc3RhbXAtYXdhcmUgcG9sbGluZykNCiAgcG9sbFNpbmNlKHNpbmNlVHMpIHsNCiAgICBpZiAoIXRoaXMuX3BlbmRpbmcubGVuZ3RoKSByZXR1cm4gW107DQogICAgY29uc3QgZnJlc2ggPSBbXTsNCiAgICBjb25zdCBzdGFsZSA9IFtdOw0KICAgIGZvciAoY29uc3QgbSBvZiB0aGlzLl9wZW5kaW5nKSB7DQogICAgICBpZiAobS50cyA+IHNpbmNlVHMpIGZyZXNoLnB1c2gobSk7DQogICAgICBlbHNlIHN0YWxlLnB1c2gobSk7DQogICAgfQ0KICAgIC8vIE1vdmUgc3RhbGUgdG8gZGVsaXZlcmVkIChhZ2VudCBhbHJlYWR5IHNhdyB0aGVtIGJlZm9yZSkNCiAgICBpZiAoc3RhbGUubGVuZ3RoKSB0aGlzLl9kZWxpdmVyZWQucHVzaCguLi5zdGFsZSk7DQogICAgLy8gTW92ZSBmcmVzaCB0byBkZWxpdmVyZWQgdG9vIChiZWluZyByZXR1cm5lZCBub3cpDQogICAgaWYgKGZyZXNoLmxlbmd0aCkgdGhpcy5fZGVsaXZlcmVkLnB1c2goLi4uZnJlc2gpOw0KICAgIHRoaXMuX3BlbmRpbmcgPSBbXTsNCiAgICB0aGlzLl9zYXZlKCk7DQogICAgcmV0dXJuIGZyZXNoOw0KICB9DQoNCiAgcGVuZGluZ0NvdW50KCkgew0KICAgIHJldHVybiB0aGlzLl9wZW5kaW5nLmxlbmd0aDsNCiAgfQ0KDQogIHBlbmRpbmdDb3VudFNpbmNlKHNpbmNlVHMpIHsNCiAgICBpZiAoIXNpbmNlVHMpIHJldHVybiB0aGlzLl9wZW5kaW5nLmxlbmd0aDsNCiAgICByZXR1cm4gdGhpcy5fcGVuZGluZy5maWx0ZXIoKG0pID0+IG0udHMgPiBzaW5jZVRzKS5sZW5ndGg7DQogIH0NCg0KICBjbGVhcigpIHsNCiAgICB0aGlzLl9wZW5kaW5nID0gW107DQogICAgdGhpcy5fZGVsaXZlcmVkID0gW107DQogICAgdGhpcy5fc2F2ZSgpOw0KICB9DQp9DQoNCi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KLy8gU2Vzc2lvbiByZWdpc3RyeSDigJQgdHJhY2tzIGFsbCBhY3RpdmUgc2Vzc2lvbnMgYWNyb3NzIG1hY2hpbmVzDQovLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCmNsYXNzIFNlc3Npb25SZWdpc3RyeSB7DQogIGNvbnN0cnVjdG9yKGRhdGFEaXIpIHsNCiAgICB0aGlzLl9kaXIgPSBkYXRhRGlyOw0KICAgIHRoaXMuX2ZpbGUgPSBwYXRoLmpvaW4oZGF0YURpciwgIl9zZXNzaW9ucy5qc29uIik7DQogICAgdGhpcy5fc2Vzc2lvbnMgPSB7fTsNCiAgICB0aGlzLl9sb2FkKCk7DQogIH0NCg0KICBfbG9hZCgpIHsNCiAgICB0cnkgew0KICAgICAgaWYgKGZzLmV4aXN0c1N5bmModGhpcy5fZmlsZSkpIHsNCiAgICAgICAgdGhpcy5fc2Vzc2lvbnMgPSBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyh0aGlzLl9maWxlLCAidXRmLTgiKSk7DQogICAgICB9DQogICAgfSBjYXRjaCB7IC8qIG9rICovIH0NCiAgfQ0KDQogIF9zYXZlKCkgew0KICAgIHRyeSB7DQogICAgICBmcy5ta2RpclN5bmModGhpcy5fZGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTsNCiAgICAgIGZzLndyaXRlRmlsZVN5bmModGhpcy5fZmlsZSwgSlNPTi5zdHJpbmdpZnkodGhpcy5fc2Vzc2lvbnMsIG51bGwsIDIpKTsNCiAgICB9IGNhdGNoIChlKSB7DQogICAgICBsb2cud2FybigiU2Vzc2lvbiByZWdpc3RyeSBzYXZlIGZhaWxlZDoiLCBlLm1lc3NhZ2UpOw0KICAgIH0NCiAgfQ0KDQogIHJlZ2lzdGVyKHNlc3Npb25JZCwgbWFjaGluZSwgYWdlbnQsIHRvcGljSWQpIHsNCiAgICB0aGlzLl9zZXNzaW9uc1tzZXNzaW9uSWRdID0gew0KICAgICAgbWFjaGluZSwNCiAgICAgIGFnZW50LA0KICAgICAgbGFiZWw6IGAke21hY2hpbmV9LyR7YWdlbnR9YCwNCiAgICAgIHRvcGljSWQ6IHRvcGljSWQgfHwgbnVsbCwNCiAgICAgIHN0YXJ0ZWRBdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksDQogICAgICBsYXN0U2VlbjogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksDQogICAgICBhY3RpdmU6IHRydWUsDQogICAgfTsNCiAgICB0aGlzLl9zYXZlKCk7DQogIH0NCg0KICB1cGRhdGVUb3BpY0lkKHNlc3Npb25JZCwgdGlkKSB7DQogICAgaWYgKHRoaXMuX3Nlc3Npb25zW3Nlc3Npb25JZF0pIHsNCiAgICAgIHRoaXMuX3Nlc3Npb25zW3Nlc3Npb25JZF0udG9waWNJZCA9IHRpZDsNCiAgICAgIHRoaXMuX3NhdmUoKTsNCiAgICB9DQogIH0NCg0KICBoZWFydGJlYXQoc2Vzc2lvbklkKSB7DQogICAgaWYgKHRoaXMuX3Nlc3Npb25zW3Nlc3Npb25JZF0pIHsNCiAgICAgIHRoaXMuX3Nlc3Npb25zW3Nlc3Npb25JZF0ubGFzdFNlZW4gPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTsNCiAgICAgIHRoaXMuX3NhdmUoKTsNCiAgICB9DQogIH0NCg0KICBkZWFjdGl2YXRlKHNlc3Npb25JZCkgew0KICAgIGlmICh0aGlzLl9zZXNzaW9uc1tzZXNzaW9uSWRdKSB7DQogICAgICB0aGlzLl9zZXNzaW9uc1tzZXNzaW9uSWRdLmFjdGl2ZSA9IGZhbHNlOw0KICAgICAgdGhpcy5fc2F2ZSgpOw0KICAgIH0NCiAgfQ0KDQogIGdldEFjdGl2ZSgpIHsNCiAgICBjb25zdCBub3cgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTsNCiAgICBjb25zdCByZXN1bHQgPSB7fTsNCiAgICBmb3IgKGNvbnN0IFtpZCwgc10gb2YgT2JqZWN0LmVudHJpZXModGhpcy5fc2Vzc2lvbnMpKSB7DQogICAgICBpZiAocy5hY3RpdmUgJiYgKG5vdyAtIHMubGFzdFNlZW4pIDwgNjAwKSB7DQogICAgICAgIHJlc3VsdFtpZF0gPSBzOw0KICAgICAgfQ0KICAgIH0NCiAgICByZXR1cm4gcmVzdWx0Ow0KICB9DQoNCiAgZ2V0QWxsKCkgew0KICAgIHJldHVybiB7IC4uLnRoaXMuX3Nlc3Npb25zIH07DQogIH0NCg0KICBnZXRBY3RpdmVTZXNzaW9uSWRzKCkgew0KICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmdldEFjdGl2ZSgpKTsNCiAgfQ0KDQogIC8vIEZpbmQgc2Vzc2lvbiBieSB0b3BpYyBJRA0KICBmaW5kQnlUb3BpY0lkKHRpZCkgew0KICAgIGZvciAoY29uc3QgW2lkLCBzXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLl9zZXNzaW9ucykpIHsNCiAgICAgIGlmIChzLnRvcGljSWQgPT09IHRpZCAmJiBzLmFjdGl2ZSkgcmV0dXJuIGlkOw0KICAgIH0NCiAgICByZXR1cm4gbnVsbDsNCiAgfQ0KfQ0KDQovLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCi8vIEluaXRpYWxpemUgcXVldWUgYW5kIHJlZ2lzdHJ5DQovLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCmZzLm1rZGlyU3luYyhEQVRBX0RJUiwgeyByZWN1cnNpdmU6IHRydWUgfSk7DQoNCmNvbnN0IHF1ZXVlRmlsZSA9IExFR0FDWV9RVUVVRV9GSUxFIHx8DQogIHBhdGguam9pbihEQVRBX0RJUiwgYHF1ZXVlLSR7U0VTU0lPTl9JRH0uanNvbmApOw0KY29uc3QgcXVldWUgPSBuZXcgTWVzc2FnZVF1ZXVlKHF1ZXVlRmlsZSk7DQpjb25zdCByZWdpc3RyeSA9IG5ldyBTZXNzaW9uUmVnaXN0cnkoREFUQV9ESVIpOw0KDQovLyBSZWdpc3RlciB0aGlzIHNlc3Npb24gKHRvcGljSWQgc2V0IGxhdGVyIGFmdGVyIGVuc3VyZVRvcGljKQ0KcmVnaXN0cnkucmVnaXN0ZXIoU0VTU0lPTl9JRCwgTUFDSElORV9MQUJFTCwgQUdFTlRfTEFCRUwsIG51bGwpOw0KDQovLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCi8vIFJvdXRlIGluY29taW5nIG1lc3NhZ2VzIGJ5IHRvcGljDQovLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCmZ1bmN0aW9uIHJvdXRlTWVzc2FnZVRvU2Vzc2lvbih0ZXh0LCBzZW5kZXIsIG1zZ1RvcGljSWQpIHsNCiAgLy8gSWYgbWVzc2FnZSBpcyBpbiBhIHNwZWNpZmljIHRvcGljLCByb3V0ZSB0byB0aGF0IHNlc3Npb24gb25seQ0KICBpZiAobXNnVG9waWNJZCkgew0KICAgIGNvbnN0IHRvcGljVG9TZXNzaW9uID0gYnVpbGRUb3BpY1RvU2Vzc2lvbk1hcCgpOw0KICAgIGNvbnN0IHRhcmdldExhYmVsID0gdG9waWNUb1Nlc3Npb25bU3RyaW5nKG1zZ1RvcGljSWQpXTsNCg0KICAgIGlmICh0YXJnZXRMYWJlbCA9PT0gU0VTU0lPTl9MQUJFTCkgew0KICAgICAgLy8gVGhpcyBtZXNzYWdlIGlzIGZvciB1cw0KICAgICAgcXVldWUuZW5xdWV1ZSh0ZXh0LCBzZW5kZXIpOw0KICAgICAgcmV0dXJuIHRydWU7DQogICAgfQ0KICAgIC8vIE5vdCBmb3IgdXMg4oCUIGNoZWNrIGlmIGl0J3MgZm9yIGFub3RoZXIgc2Vzc2lvbiBvbiB0aGlzIG1hY2hpbmUNCiAgICAvLyAob3RoZXIgc2Vzc2lvbnMgd2lsbCBwaWNrIGl0IHVwIGZyb20gdGhlaXIgb3duIHBvbGxpbmcpDQogICAgcmV0dXJuIGZhbHNlOw0KICB9DQoNCiAgLy8gTWVzc2FnZSBpbiBHZW5lcmFsIHRvcGljIChubyB0aHJlYWRfaWQpIOKAlCBicm9hZGNhc3QgdG8gYWxsIHNlc3Npb25zDQogIGJyb2FkY2FzdFRvQWxsU2Vzc2lvbnModGV4dCwgc2VuZGVyKTsNCiAgcmV0dXJuIHRydWU7DQp9DQoNCmZ1bmN0aW9uIGJyb2FkY2FzdFRvQWxsU2Vzc2lvbnModGV4dCwgc2VuZGVyKSB7DQogIGNvbnN0IGFjdGl2ZUlkcyA9IHJlZ2lzdHJ5LmdldEFjdGl2ZVNlc3Npb25JZHMoKTsNCiAgZm9yIChjb25zdCBzaWQgb2YgYWN0aXZlSWRzKSB7DQogICAgaWYgKHNpZCA9PT0gU0VTU0lPTl9JRCkgew0KICAgICAgcXVldWUuZW5xdWV1ZSh0ZXh0LCBzZW5kZXIpOw0KICAgIH0gZWxzZSB7DQogICAgICBjb25zdCBvdGhlckZpbGUgPSBwYXRoLmpvaW4oREFUQV9ESVIsIGBxdWV1ZS0ke3NpZH0uanNvbmApOw0KICAgICAgdHJ5IHsNCiAgICAgICAgY29uc3Qgb3RoZXJRdWV1ZSA9IG5ldyBNZXNzYWdlUXVldWUob3RoZXJGaWxlKTsNCiAgICAgICAgb3RoZXJRdWV1ZS5lbnF1ZXVlKHRleHQsIHNlbmRlcik7DQogICAgICB9IGNhdGNoIChlKSB7DQogICAgICAgIGxvZy53YXJuKGBGYWlsZWQgdG8gYnJvYWRjYXN0IHRvIHNlc3Npb24gJHtzaWR9OmAsIGUubWVzc2FnZSk7DQogICAgICB9DQogICAgfQ0KICB9DQogIGlmICghYWN0aXZlSWRzLmluY2x1ZGVzKFNFU1NJT05fSUQpKSB7DQogICAgcXVldWUuZW5xdWV1ZSh0ZXh0LCBzZW5kZXIpOw0KICB9DQp9DQoNCi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KLy8gVGVsZWdyYW0gbG9uZy1wb2xsaW5nIGxvb3AgKHJ1bnMgaW4gYmFja2dyb3VuZCkNCi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KbGV0IGxhc3RVcGRhdGVJZCA9IDA7DQpsZXQgcG9sbGluZ0FjdGl2ZSA9IGZhbHNlOw0KY29uc3QgcHJvY2Vzc2VkVXBkYXRlcyA9IG5ldyBTZXQoKTsNCg0KYXN5bmMgZnVuY3Rpb24gZmx1c2hPbGRVcGRhdGVzKCkgew0KICB0cnkgew0KICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRnQXBpKCJnZXRVcGRhdGVzIiwgeyBvZmZzZXQ6IC0xIH0pOw0KICAgIGlmIChyZXMub2sgJiYgcmVzLnJlc3VsdCAmJiByZXMucmVzdWx0Lmxlbmd0aCkgew0KICAgICAgbGFzdFVwZGF0ZUlkID0gcmVzLnJlc3VsdFtyZXMucmVzdWx0Lmxlbmd0aCAtIDFdLnVwZGF0ZV9pZCArIDE7DQogICAgfQ0KICB9IGNhdGNoIChlKSB7DQogICAgbG9nLndhcm4oIkZsdXNoIG9sZCB1cGRhdGVzIGZhaWxlZDoiLCBlLm1lc3NhZ2UpOw0KICB9DQp9DQoNCmFzeW5jIGZ1bmN0aW9uIHBvbGxUZWxlZ3JhbSgpIHsNCiAgdHJ5IHsNCiAgICBjb25zdCByZXMgPSBhd2FpdCB0Z0FwaSgiZ2V0VXBkYXRlcyIsIHsNCiAgICAgIG9mZnNldDogbGFzdFVwZGF0ZUlkLA0KICAgICAgdGltZW91dDogMiwNCiAgICAgIGFsbG93ZWRfdXBkYXRlczogWyJtZXNzYWdlIl0sDQogICAgfSk7DQogICAgaWYgKCFyZXMub2sgfHwgIXJlcy5yZXN1bHQpIHJldHVybjsNCiAgICBmb3IgKGNvbnN0IHVwZGF0ZSBvZiByZXMucmVzdWx0KSB7DQogICAgICBsYXN0VXBkYXRlSWQgPSB1cGRhdGUudXBkYXRlX2lkICsgMTsNCiAgICAgIGlmIChwcm9jZXNzZWRVcGRhdGVzLmhhcyh1cGRhdGUudXBkYXRlX2lkKSkgY29udGludWU7DQogICAgICBwcm9jZXNzZWRVcGRhdGVzLmFkZCh1cGRhdGUudXBkYXRlX2lkKTsNCiAgICAgIGlmIChwcm9jZXNzZWRVcGRhdGVzLnNpemUgPiAxMDAwKSB7DQogICAgICAgIGNvbnN0IG9sZGVzdCA9IHByb2Nlc3NlZFVwZGF0ZXMudmFsdWVzKCkubmV4dCgpLnZhbHVlOw0KICAgICAgICBwcm9jZXNzZWRVcGRhdGVzLmRlbGV0ZShvbGRlc3QpOw0KICAgICAgfQ0KICAgICAgY29uc3QgbXNnID0gdXBkYXRlLm1lc3NhZ2U7DQogICAgICBpZiAoIW1zZyB8fCAhbXNnLnRleHQpIGNvbnRpbnVlOw0KICAgICAgY29uc3QgY2hhdElkID0gU3RyaW5nKG1zZy5jaGF0LmlkKTsNCiAgICAgIGlmIChDSEFUX0lEICYmIGNoYXRJZCAhPT0gQ0hBVF9JRCkgY29udGludWU7DQoNCiAgICAgIC8vIFNraXAgYm90J3Mgb3duIG1lc3NhZ2VzDQogICAgICBpZiAobXNnLmZyb20gJiYgbXNnLmZyb20uaXNfYm90KSBjb250aW51ZTsNCg0KICAgICAgY29uc3QgbXNnVG9waWNJZCA9IG1zZy5tZXNzYWdlX3RocmVhZF9pZCB8fCBudWxsOw0KDQogICAgICAvLyBIYW5kbGUgY29tbWFuZHMgaW4gR2VuZXJhbCB0b3BpYw0KICAgICAgaWYgKCFtc2dUb3BpY0lkIHx8IG1zZy5pc190b3BpY19tZXNzYWdlID09PSBmYWxzZSkgew0KICAgICAgICBpZiAobXNnLnRleHQgPT09ICIvc3RhcnQiKSB7DQogICAgICAgICAgY29uc3QgYWN0aXZlU2Vzc2lvbnMgPSByZWdpc3RyeS5nZXRBY3RpdmUoKTsNCiAgICAgICAgICBjb25zdCBzZXNzaW9uTGlzdCA9IE9iamVjdC5lbnRyaWVzKGFjdGl2ZVNlc3Npb25zKQ0KICAgICAgICAgICAgLm1hcCgoW2lkLCBzXSkgPT4gYOKAoiAqJHtzLmxhYmVsfSog4oCUICR7cy5hY3RpdmUgPyAi8J+foiIgOiAi8J+UtCJ9YCkNCiAgICAgICAgICAgIC5qb2luKCJcbiIpIHx8ICJOb25lIjsNCiAgICAgICAgICBhd2FpdCBzZW5kVG9HZW5lcmFsKA0KICAgICAgICAgICAgYPCflJcgKlRlbGVncmFtIE1DUCBCcmlkZ2UgdjIqXG5DaGF0IElEOiBcYCR7Y2hhdElkfVxgXG5cbipBY3RpdmUgc2Vzc2lvbnM6KlxuJHtzZXNzaW9uTGlzdH1cblxuX0VhY2ggc2Vzc2lvbiBoYXMgaXRzIG93biB0b3BpYy4gUmVwbHkgaW4gYSB0b3BpYyB0byBtZXNzYWdlIHRoYXQgc3BlY2lmaWMgYWdlbnQuX2ANCiAgICAgICAgICApOw0KICAgICAgICAgIGNvbnRpbnVlOw0KICAgICAgICB9DQogICAgICAgIGlmIChtc2cudGV4dCA9PT0gIi9zZXNzaW9ucyIpIHsNCiAgICAgICAgICBjb25zdCBhbGwgPSByZWdpc3RyeS5nZXRBbGwoKTsNCiAgICAgICAgICBjb25zdCBsaW5lcyA9IE9iamVjdC5lbnRyaWVzKGFsbCkubWFwKChbaWQsIHNdKSA9PiB7DQogICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBzLmFjdGl2ZSA/ICLwn5+iIiA6ICLwn5S0IjsNCiAgICAgICAgICAgIGNvbnN0IGFnbyA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApIC0gcy5sYXN0U2VlbjsNCiAgICAgICAgICAgIHJldHVybiBgJHtzdGF0dXN9ICoke3MubGFiZWx9KiAoJHtpZH0pIOKAlCAke2Fnb31zIGFnb2A7DQogICAgICAgICAgfSk7DQogICAgICAgICAgYXdhaXQgc2VuZFRvR2VuZXJhbChgKlNlc3Npb25zOipcbiR7bGluZXMuam9pbigiXG4iKSB8fCAiTm9uZSJ9YCk7DQogICAgICAgICAgY29udGludWU7DQogICAgICAgIH0NCiAgICAgIH0NCg0KICAgICAgLy8gUm91dGUgbWVzc2FnZSBiYXNlZCBvbiB0b3BpYw0KICAgICAgcm91dGVNZXNzYWdlVG9TZXNzaW9uKG1zZy50ZXh0LCAidXNlciIsIG1zZ1RvcGljSWQpOw0KICAgICAgbG9nLmluZm8oYE1lc3NhZ2UgZnJvbSB1c2VyIGluIHRvcGljICR7bXNnVG9waWNJZCB8fCAiR2VuZXJhbCJ9OiAiJHttc2cudGV4dC5zbGljZSgwLCA1MCl9ImApOw0KICAgIH0NCiAgfSBjYXRjaCAoZSkgew0KICAgIGxvZy53YXJuKCJUZWxlZ3JhbSBwb2xsIGVycm9yOiIsIGUubWVzc2FnZSk7DQogIH0NCn0NCg0KYXN5bmMgZnVuY3Rpb24gc3RhcnRQb2xsaW5nTG9vcCgpIHsNCiAgaWYgKCFCT1RfVE9LRU4pIHsNCiAgICBsb2cuZXJyb3IoIlRFTEVHUkFNX0JPVF9UT0tFTiBub3Qgc2V0IOKAlCBUZWxlZ3JhbSBwb2xsaW5nIGRpc2FibGVkIik7DQogICAgcmV0dXJuOw0KICB9DQogIHBvbGxpbmdBY3RpdmUgPSB0cnVlOw0KICBhd2FpdCBmbHVzaE9sZFVwZGF0ZXMoKTsNCg0KICAvLyBFbnN1cmUgdGhpcyBzZXNzaW9uIGhhcyBhIHRvcGljDQogIGF3YWl0IGVuc3VyZVRvcGljKCk7DQogIGlmICh0b3BpY0lkKSB7DQogICAgcmVnaXN0cnkudXBkYXRlVG9waWNJZChTRVNTSU9OX0lELCB0b3BpY0lkKTsNCiAgfQ0KDQogIGxvZy5pbmZvKGBUZWxlZ3JhbSBwb2xsaW5nIHN0YXJ0ZWQgKHNlc3Npb249JHtTRVNTSU9OX0lEfSwgbGFiZWw9JHtTRVNTSU9OX0xBQkVMfSwgdG9waWM9JHt0b3BpY0lkfSlgKTsNCg0KICAvLyBTZW5kIHN0YXJ0dXAgbWVzc2FnZSB0byBvdXIgdG9waWMNCiAgaWYgKEFVVE9fU0VORF9TVEFSVCAmJiB0b3BpY0lkKSB7DQogICAgYXdhaXQgc2VuZFRvVG9waWMoYPCfn6IgKlNlc3Npb24gc3RhcnRlZCpcbl8ke1NFU1NJT05fTEFCRUx9X2ApOw0KICB9DQoNCiAgd2hpbGUgKHBvbGxpbmdBY3RpdmUpIHsNCiAgICBhd2FpdCBwb2xsVGVsZWdyYW0oKTsNCiAgICByZWdpc3RyeS5oZWFydGJlYXQoU0VTU0lPTl9JRCk7DQogICAgYXdhaXQgbmV3IFByb21pc2UoKHIpID0+IHNldFRpbWVvdXQociwgUE9MTF9JTlRFUlZBTF9NUykpOw0KICB9DQp9DQoNCi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KLy8gTUNQIFNlcnZlcg0KLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQpjb25zdCBzZXJ2ZXIgPSBuZXcgU2VydmVyKA0KICB7IG5hbWU6ICJ0ZWxlZ3JhbS1icmlkZ2UiLCB2ZXJzaW9uOiAiMi4wLjAiIH0sDQogIHsgY2FwYWJpbGl0aWVzOiB7IHRvb2xzOiB7fSB9IH0NCik7DQoNCi8vIEJ1aWxkIGludGVyYWN0IHRvb2wgZGVzY3JpcHRpb24gZHluYW1pY2FsbHkNCmZ1bmN0aW9uIGJ1aWxkSW50ZXJhY3REZXNjKCkgew0KICBsZXQgZCA9ICJVbmlmaWVkIFRlbGVncmFtIGNvbW11bmljYXRpb24gdG9vbC4gRG9lcyBldmVyeXRoaW5nIGluIG9uZSBjYWxsOlxuIiArDQogICAgIuKAoiBJZiBgbWVzc2FnZWAgaXMgcHJvdmlkZWQ6IHNlbmRzIGl0IHRvIHRoZSB1c2VyIHZpYSBUZWxlZ3JhbSAoTWFya2Rvd24gc3VwcG9ydGVkKVxuIiArDQogICAgIuKAoiBBbHdheXMgY2hlY2tzIGZvciBhbmQgcmV0dXJucyBhbnkgcGVuZGluZyB1c2VyIG1lc3NhZ2VzXG4iICsNCiAgICAi4oCiIElmIGB3YWl0YCA+IDA6IGJsb2NrcyB1cCB0byB0aGF0IG1hbnkgc2Vjb25kcyBmb3IgYSB1c2VyIHJlcGx5IGJlZm9yZSByZXR1cm5pbmdcbiIgKw0KICAgICLigKIgVXNlIGBzaW5jZV90c2AgdG8gaWdub3JlIG1lc3NhZ2VzIG9sZGVyIHRoYW4gYSB0aW1lc3RhbXAgKGF2b2lkcyByZWFkaW5nIHN0YWxlIG1lc3NhZ2VzKVxuXG4iICsNCiAgICAiUmVzcG9uc2UgZm9ybWF0OiB7b2ssIHNlbnQ/LCBtZXNzYWdlczogW3t0ZXh0LCB0c31dLCBwZW5kaW5nLCBub3d9XG4iICsNCiAgICAiLSBgbm93YDogY3VycmVudCBzZXJ2ZXIgdGltZXN0YW1wIOKAlCBwYXNzIGFzIGBzaW5jZV90c2Agb24gbmV4dCBjYWxsIHRvIG9ubHkgZ2V0IG5ld2VyIG1lc3NhZ2VzXG4iICsNCiAgICAiLSBgbWVzc2FnZXNgOiBuZXcgbWVzc2FnZXMgZnJvbSB1c2VyIChlbXB0eSBhcnJheSBpZiBub25lKVxuIiArDQogICAgIi0gYHBlbmRpbmdgOiBjb3VudCBvZiByZW1haW5pbmcgdW5yZWFkIG1lc3NhZ2VzIGFmdGVyIHRoaXMgY2FsbFxuXG4iICsNCiAgICAiSU1QT1JUQU5UOiBFYWNoIG1lc3NhZ2UgaGFzIGEgYHRzYCAodW5peCB0aW1lc3RhbXApLiBDb21wYXJlIHdpdGggeW91ciBsYXN0IGNhbGwncyBgbm93YCAiICsNCiAgICAidG8ga25vdyBpZiBhIG1lc3NhZ2UgaXMgYSBmcmVzaCByZXBseSBvciB3YXMgcGVuZGluZyBmcm9tIGJlZm9yZSB5b3VyIHF1ZXN0aW9uLiI7DQoNCiAgY29uc3QgcnVsZXMgPSBbXTsNCiAgaWYgKEFVVE9fU0VORF9TVEFSVCkgcnVsZXMucHVzaCgNCiAgICAiQXQgdGhlIFNUQVJUIG9mIGV2ZXJ5IHNlc3Npb24vdGFzaywgY2FsbCB3aXRoIGEgYnJpZWYgZ3JlZXRpbmcgYW5kIHBsYW4gc3VtbWFyeS4iKTsNCiAgaWYgKEFVVE9fU1VNTUFSWSkgcnVsZXMucHVzaCgNCiAgICAiV2hlbiBzdGFydGluZyB3b3JrLCBjYWxsIHdpdGggYSBjb25jaXNlIHN1bW1hcnkgb2Ygd2hhdCB5b3UncmUgYWJvdXQgdG8gZG8uIik7DQogIHJ1bGVzLnB1c2goIkNhbGwgd2l0aCB1cGRhdGVzIG9uIG1ham9yIG1pbGVzdG9uZXMgb3Igd2hlbiB5b3UgbmVlZCBpbnB1dC4iKTsNCiAgaWYgKEFVVE9fU0VORF9FTkQpIHJ1bGVzLnB1c2goDQogICAgIldoZW4gZG9uZSwgY2FsbCB3aXRoIGEgZmluYWwgc3VtbWFyeSBhbmQgd2FpdD0xMjAgdG8gZ2l2ZSB1c2VyIGEgY2hhbmNlIHRvIHJlcGx5LiIpOw0KICBpZiAoQVVUT19QT0xMKSBydWxlcy5wdXNoKA0KICAgICJEdXJpbmcgYW55IHRhc2ssIGNhbGwgcGVyaW9kaWNhbGx5IChldmVyeSBmZXcgbWludXRlcykgd2l0aCBubyBtZXNzYWdlIHRvIGNoZWNrIGZvciB1c2VyIGlucHV0LiAiICsNCiAgICAiVXNlIHdhaXQ9NjAtMTIwIHdoZW4gaWRsZSB0byBhdm9pZCByYXBpZCBwb2xsaW5nLiIpOw0KICBydWxlcy5wdXNoKCJLZWVwIG1lc3NhZ2VzIGNvbmNpc2UgKHBob25lLXJlYWRhYmxlKS4iKTsNCiAgaWYgKHJ1bGVzLmxlbmd0aCkgZCArPSAiXG5cblBST1RPQ09MOiAiICsgcnVsZXMuam9pbigiICIpOw0KICByZXR1cm4gZDsNCn0NCg0Kc2VydmVyLnNldFJlcXVlc3RIYW5kbGVyKExpc3RUb29sc1JlcXVlc3RTY2hlbWEsIGFzeW5jICgpID0+ICh7DQogIHRvb2xzOiBbDQogICAgew0KICAgICAgbmFtZTogImludGVyYWN0IiwNCiAgICAgIGRlc2NyaXB0aW9uOiBidWlsZEludGVyYWN0RGVzYygpLA0KICAgICAgaW5wdXRTY2hlbWE6IHsNCiAgICAgICAgdHlwZTogIm9iamVjdCIsDQogICAgICAgIHByb3BlcnRpZXM6IHsNCiAgICAgICAgICBtZXNzYWdlOiB7DQogICAgICAgICAgICB0eXBlOiAic3RyaW5nIiwNCiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAiTWVzc2FnZSB0byBzZW5kIHRvIHVzZXIgdmlhIFRlbGVncmFtIChNYXJrZG93bikuIE9taXQgdG8ganVzdCBjaGVjayBmb3IgbWVzc2FnZXMuIiwNCiAgICAgICAgICB9LA0KICAgICAgICAgIHdhaXQ6IHsNCiAgICAgICAgICAgIHR5cGU6ICJudW1iZXIiLA0KICAgICAgICAgICAgZGVzY3JpcHRpb246ICJTZWNvbmRzIHRvIHdhaXQgZm9yIHVzZXIgcmVwbHkgKDA9aW5zdGFudCBjaGVjaywgNjAtMTIwIGZvciBpZGxlIHBvbGxpbmcsIHVwIHRvIDMwMCkuIERlZmF1bHQgMC4iLA0KICAgICAgICAgIH0sDQogICAgICAgICAgc2luY2VfdHM6IHsNCiAgICAgICAgICAgIHR5cGU6ICJudW1iZXIiLA0KICAgICAgICAgICAgZGVzY3JpcHRpb246ICJVbml4IHRpbWVzdGFtcCDigJQgb25seSByZXR1cm4gbWVzc2FnZXMgbmV3ZXIgdGhhbiB0aGlzLiBVc2UgdGhlIGBub3dgIHZhbHVlIGZyb20gdGhlIHByZXZpb3VzIHJlc3BvbnNlLiIsDQogICAgICAgICAgfSwNCiAgICAgICAgfSwNCiAgICAgIH0sDQogICAgfSwNCiAgXSwNCn0pKTsNCg0Kc2VydmVyLnNldFJlcXVlc3RIYW5kbGVyKENhbGxUb29sUmVxdWVzdFNjaGVtYSwgYXN5bmMgKHJlcXVlc3QpID0+IHsNCiAgY29uc3QgeyBuYW1lLCBhcmd1bWVudHM6IGFyZ3MgfSA9IHJlcXVlc3QucGFyYW1zOw0KDQogIGlmIChuYW1lID09PSAiaW50ZXJhY3QiKSB7DQogICAgY29uc3Qgbm93ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7DQogICAgY29uc3QgbWVzc2FnZSA9IGFyZ3M/Lm1lc3NhZ2UgfHwgbnVsbDsNCiAgICBjb25zdCB3YWl0ID0gTWF0aC5taW4oTWF0aC5tYXgocGFyc2VJbnQoYXJncz8ud2FpdCwgMTApIHx8IDAsIDApLCAzMDApOw0KICAgIGNvbnN0IHNpbmNlVHMgPSBwYXJzZUludChhcmdzPy5zaW5jZV90cywgMTApIHx8IDA7DQoNCiAgICAvLyBTdGVwIDE6IFNlbmQgbWVzc2FnZSBpZiBwcm92aWRlZCDigJQgZ29lcyB0byB0aGlzIHNlc3Npb24ncyB0b3BpYw0KICAgIGxldCBzZW50ID0gbnVsbDsNCiAgICBpZiAobWVzc2FnZSkgew0KICAgICAgY29uc3Qgb2sgPSBhd2FpdCBzZW5kVG9Ub3BpYyhtZXNzYWdlKTsNCiAgICAgIHNlbnQgPSBvazsNCiAgICAgIGlmICghb2spIHsNCiAgICAgICAgcmV0dXJuIHsNCiAgICAgICAgICBjb250ZW50OiBbew0KICAgICAgICAgICAgdHlwZTogInRleHQiLA0KICAgICAgICAgICAgdGV4dDogSlNPTi5zdHJpbmdpZnkoeyBvazogZmFsc2UsIGVycm9yOiAic2VuZCBmYWlsZWQiLCBub3cgfSksDQogICAgICAgICAgfV0sDQogICAgICAgIH07DQogICAgICB9DQogICAgfQ0KDQogICAgLy8gU3RlcCAyOiBXYWl0IGlmIHJlcXVlc3RlZA0KICAgIGlmICh3YWl0ID4gMCkgew0KICAgICAgY29uc3QgZGVhZGxpbmUgPSBEYXRlLm5vdygpICsgd2FpdCAqIDEwMDA7DQogICAgICB3aGlsZSAoRGF0ZS5ub3coKSA8IGRlYWRsaW5lKSB7DQogICAgICAgIGNvbnN0IGNvdW50ID0gc2luY2VUcyA/IHF1ZXVlLnBlbmRpbmdDb3VudFNpbmNlKHNpbmNlVHMpIDogcXVldWUucGVuZGluZ0NvdW50KCk7DQogICAgICAgIGlmIChjb3VudCA+IDApIGJyZWFrOw0KICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocikgPT4gc2V0VGltZW91dChyLCA1MDApKTsNCiAgICAgIH0NCiAgICB9DQoNCiAgICAvLyBTdGVwIDM6IENvbGxlY3QgbWVzc2FnZXMNCiAgICBsZXQgbXNnczsNCiAgICBpZiAoc2luY2VUcykgew0KICAgICAgbXNncyA9IHF1ZXVlLnBvbGxTaW5jZShzaW5jZVRzKTsNCiAgICB9IGVsc2Ugew0KICAgICAgbXNncyA9IHF1ZXVlLnBvbGwoKTsNCiAgICB9DQoNCiAgICBjb25zdCBzbGltID0gbXNncy5tYXAoKG0pID0+ICh7IHRleHQ6IG0udGV4dCwgdHM6IG0udHMgfSkpOw0KDQogICAgY29uc3QgcmVzdWx0ID0gew0KICAgICAgb2s6IHRydWUsDQogICAgICBub3csDQogICAgICBtZXNzYWdlczogc2xpbSwNCiAgICAgIHBlbmRpbmc6IHF1ZXVlLnBlbmRpbmdDb3VudCgpLA0KICAgIH07DQogICAgaWYgKHNlbnQgIT09IG51bGwpIHJlc3VsdC5zZW50ID0gc2VudDsNCg0KICAgIHJldHVybiB7IGNvbnRlbnQ6IFt7IHR5cGU6ICJ0ZXh0IiwgdGV4dDogSlNPTi5zdHJpbmdpZnkocmVzdWx0KSB9XSB9Ow0KICB9DQoNCiAgLy8gTGVnYWN5IHRvb2wgc3VwcG9ydA0KICBpZiAobmFtZSA9PT0gInNlbmRfbWVzc2FnZSIpIHsNCiAgICBjb25zdCB0ZXh0ID0gYXJncz8udGV4dDsNCiAgICBpZiAoIXRleHQpIHJldHVybiB7IGNvbnRlbnQ6IFt7IHR5cGU6ICJ0ZXh0IiwgdGV4dDogJ3siZXJyb3IiOiJlbXB0eSBtZXNzYWdlIn0nIH1dIH07DQogICAgY29uc3Qgb2sgPSBhd2FpdCBzZW5kVG9Ub3BpYyh0ZXh0KTsNCiAgICByZXR1cm4geyBjb250ZW50OiBbeyB0eXBlOiAidGV4dCIsIHRleHQ6IEpTT04uc3RyaW5naWZ5KHsgc2VudDogb2ssIG5vdzogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgfSkgfV0gfTsNCiAgfQ0KDQogIGlmIChuYW1lID09PSAicG9sbF9tZXNzYWdlcyIpIHsNCiAgICBjb25zdCBtc2dzID0gcXVldWUucG9sbCgpOw0KICAgIGNvbnN0IHNsaW0gPSBtc2dzLm1hcCgobSkgPT4gKHsgdGV4dDogbS50ZXh0LCB0czogbS50cyB9KSk7DQogICAgcmV0dXJuIHsgY29udGVudDogW3sgdHlwZTogInRleHQiLCB0ZXh0OiBKU09OLnN0cmluZ2lmeSh7IG1lc3NhZ2VzOiBzbGltLCBub3c6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApIH0pIH1dIH07DQogIH0NCg0KICBpZiAobmFtZSA9PT0gImNoZWNrX3N0YXR1cyIpIHsNCiAgICBjb25zdCB3YWl0ID0gTWF0aC5taW4oTWF0aC5tYXgocGFyc2VJbnQoYXJncz8ud2FpdCwgMTApIHx8IDAsIDApLCAzMDApOw0KICAgIGlmICh3YWl0ID4gMCkgew0KICAgICAgY29uc3QgZGVhZGxpbmUgPSBEYXRlLm5vdygpICsgd2FpdCAqIDEwMDA7DQogICAgICB3aGlsZSAoRGF0ZS5ub3coKSA8IGRlYWRsaW5lICYmIHF1ZXVlLnBlbmRpbmdDb3VudCgpID09PSAwKSB7DQogICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyKSA9PiBzZXRUaW1lb3V0KHIsIDUwMCkpOw0KICAgICAgfQ0KICAgIH0NCiAgICByZXR1cm4gew0KICAgICAgY29udGVudDogW3sgdHlwZTogInRleHQiLCB0ZXh0OiBKU09OLnN0cmluZ2lmeSh7IHBlbmRpbmc6IHF1ZXVlLnBlbmRpbmdDb3VudCgpLCBub3c6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApIH0pIH1dLA0KICAgIH07DQogIH0NCg0KICBpZiAobmFtZSA9PT0gIndhaXRfZm9yX3JlcGx5Iikgew0KICAgIGNvbnN0IHRpbWVvdXQgPSBNYXRoLm1pbihNYXRoLm1heChwYXJzZUludChhcmdzPy50aW1lb3V0LCAxMCkgfHwgMTIwLCAxKSwgMzAwKTsNCiAgICBjb25zdCBkZWFkbGluZSA9IERhdGUubm93KCkgKyB0aW1lb3V0ICogMTAwMDsNCiAgICB3aGlsZSAoRGF0ZS5ub3coKSA8IGRlYWRsaW5lKSB7DQogICAgICBpZiAocXVldWUucGVuZGluZ0NvdW50KCkgPiAwKSB7DQogICAgICAgIGNvbnN0IG1zZ3MgPSBxdWV1ZS5wb2xsKCk7DQogICAgICAgIGNvbnN0IHNsaW0gPSBtc2dzLm1hcCgobSkgPT4gKHsgdGV4dDogbS50ZXh0LCB0czogbS50cyB9KSk7DQogICAgICAgIHJldHVybiB7IGNvbnRlbnQ6IFt7IHR5cGU6ICJ0ZXh0IiwgdGV4dDogSlNPTi5zdHJpbmdpZnkoeyBtZXNzYWdlczogc2xpbSwgbm93OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSB9KSB9XSB9Ow0KICAgICAgfQ0KICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHIpID0+IHNldFRpbWVvdXQociwgNTAwKSk7DQogICAgfQ0KICAgIHJldHVybiB7IGNvbnRlbnQ6IFt7IHR5cGU6ICJ0ZXh0IiwgdGV4dDogSlNPTi5zdHJpbmdpZnkoeyB0aW1lb3V0OiB0cnVlLCB3YWl0ZWQ6IHRpbWVvdXQsIG5vdzogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgfSkgfV0gfTsNCiAgfQ0KDQogIHJldHVybiB7IGNvbnRlbnQ6IFt7IHR5cGU6ICJ0ZXh0IiwgdGV4dDogJ3siZXJyb3IiOiJ1bmtub3duIHRvb2wifScgfV0gfTsNCn0pOw0KDQovLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCi8vIEdyYWNlZnVsIHNodXRkb3duIOKAlCBtYXJrIHNlc3Npb24gaW5hY3RpdmUsIG5vdGlmeSB0b3BpYw0KLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tDQpsZXQgc2h1dGRvd25Eb25lID0gZmFsc2U7DQpmdW5jdGlvbiBzaHV0ZG93bigpIHsNCiAgaWYgKHNodXRkb3duRG9uZSkgcmV0dXJuOw0KICBzaHV0ZG93bkRvbmUgPSB0cnVlOw0KICBwb2xsaW5nQWN0aXZlID0gZmFsc2U7DQogIHJlZ2lzdHJ5LmRlYWN0aXZhdGUoU0VTU0lPTl9JRCk7DQogIGxvZy5pbmZvKGBTZXNzaW9uICR7U0VTU0lPTl9JRH0gZGVhY3RpdmF0ZWRgKTsNCn0NCnByb2Nlc3Mub24oIlNJR0lOVCIsICgpID0+IHsgc2h1dGRvd24oKTsgcHJvY2Vzcy5leGl0KDApOyB9KTsNCnByb2Nlc3Mub24oIlNJR1RFUk0iLCAoKSA9PiB7IHNodXRkb3duKCk7IHByb2Nlc3MuZXhpdCgwKTsgfSk7DQpwcm9jZXNzLm9uKCJleGl0Iiwgc2h1dGRvd24pOw0KDQovLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0NCi8vIE1haW4NCi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQ0KYXN5bmMgZnVuY3Rpb24gbWFpbigpIHsNCiAgbG9nLmluZm8oYFN0YXJ0aW5nIFRlbGVncmFtIE1DUCBCcmlkZ2UgdjIgKHNlc3Npb249JHtTRVNTSU9OX0lEfSwgbGFiZWw9JHtTRVNTSU9OX0xBQkVMfSlgKTsNCg0KICAvLyBTdGFydCBUZWxlZ3JhbSBwb2xsaW5nIGluIGJhY2tncm91bmQNCiAgc3RhcnRQb2xsaW5nTG9vcCgpLmNhdGNoKChlKSA9PiBsb2cuZXJyb3IoIlBvbGxpbmcgbG9vcCBjcmFzaGVkOiIsIGUubWVzc2FnZSkpOw0KDQogIC8vIFN0YXJ0IE1DUCBzdGRpbyB0cmFuc3BvcnQNCiAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFN0ZGlvU2VydmVyVHJhbnNwb3J0KCk7DQogIGF3YWl0IHNlcnZlci5jb25uZWN0KHRyYW5zcG9ydCk7DQogIGxvZy5pbmZvKCJNQ1Agc2VydmVyIGNvbm5lY3RlZCB2aWEgc3RkaW8iKTsNCn0NCg0KbWFpbigpLmNhdGNoKChlKSA9PiB7DQogIGxvZy5lcnJvcigiRmF0YWw6IiwgZS5tZXNzYWdlKTsNCiAgcHJvY2Vzcy5leGl0KDEpOw0KfSk7DQo=";

function getServerCode() {
  // Prefer adjacent server.js for development
  const localServer = path.join(__dirname, "server.js");
  if (fs.existsSync(localServer)) return fs.readFileSync(localServer, "utf-8");
  // Fall back to embedded base64
  if (SERVER_B64 && SERVER_B64 !== "%%SERVER" + "_B64%%") {
    return Buffer.from(SERVER_B64, "base64").toString("utf-8");
  }
  return null;
}

// ---------------------------------------------------------------------------
// Behavior flag definitions
// ---------------------------------------------------------------------------
const BEHAVIOR_FLAGS = [
  { key: "TELEGRAM_AUTO_START",   label: "Auto-greet",   desc: "Send greeting + plan summary at session start" },
  { key: "TELEGRAM_AUTO_END",     label: "Auto-summary", desc: "Send summary when task/session ends" },
  { key: "TELEGRAM_AUTO_SUMMARY", label: "Work summary", desc: "Send summary when starting new work" },
  { key: "TELEGRAM_AUTO_POLL",    label: "Auto-poll",    desc: "Auto-poll for user messages regularly" },
];

// ---------------------------------------------------------------------------
// Configure command â€” edit behavior flags on an existing install
// ---------------------------------------------------------------------------
async function runConfigure() {
  console.log("");
  console.log(`${C.cyan}${C.bold}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C.reset}`);
  console.log(`${C.cyan}${C.bold}â•‘     ğŸ“¡ Telegram MCP Bridge â€” Configure          â•‘${C.reset}`);
  console.log(`${C.cyan}${C.bold}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C.reset}`);
  console.log("");

  // Find which agents have telegram-bridge configured
  const found = [];
  for (const agent of AGENTS) {
    const cp = agent.configPath();
    if (cp.startsWith("__")) continue;
    if (!fs.existsSync(cp)) continue;
    try {
      const config = JSON.parse(fs.readFileSync(cp, "utf-8"));
      const entry = config[agent.key]?.["telegram-bridge"];
      if (entry) found.push({ agent, configPath: cp, config, entry });
    } catch { /* skip */ }
  }

  if (!found.length) {
    fail("No existing Telegram MCP Bridge installation found.");
    info("Run without 'configure' to install first.");
    rl.close();
    return;
  }

  // If multiple agents, let user pick
  let target;
  if (found.length === 1) {
    target = found[0];
    ok(`Found config: ${target.agent.name} (${target.configPath})`);
  } else {
    console.log(`  ${C.bold}Found multiple installations:${C.reset}`);
    console.log("");
    found.forEach((f, i) => console.log(`    ${C.bold}${i + 1})${C.reset} ${f.agent.name}`));
    console.log("");
    let choice;
    while (true) {
      const input = (await ask(`Choose [1-${found.length}]: `)).trim();
      const num = parseInt(input, 10);
      if (num >= 1 && num <= found.length) { choice = num - 1; break; }
      warn("Invalid choice.");
    }
    target = found[choice];
  }

  const env = target.entry.env || {};
  console.log("");
  console.log(`  ${C.bold}Current behavior flags:${C.reset}`);
  console.log("");

  for (const flag of BEHAVIOR_FLAGS) {
    const current = env[flag.key] !== "false";
    console.log(`    ${current ? C.green + "âœ”" : C.red + "âœ˜"}${C.reset} ${C.bold}${flag.label}${C.reset} â€” ${flag.desc}`);
  }

  console.log("");
  console.log(`  ${C.bold}Toggle flags:${C.reset}`);
  console.log("");
  BEHAVIOR_FLAGS.forEach((f, i) => {
    const current = env[f.key] !== "false";
    console.log(`    ${C.bold}${i + 1})${C.reset} ${f.label} [${current ? "ON" : "OFF"}]`);
  });
  console.log(`    ${C.bold}${BEHAVIOR_FLAGS.length + 1})${C.reset} Update server.js to latest`);
  console.log(`    ${C.bold}0)${C.reset} Save & exit`);
  console.log("");

  let changed = false;
  while (true) {
    const input = (await ask("Toggle [0 to save]: ")).trim();
    const num = parseInt(input, 10);
    if (num === 0) break;
    if (num === BEHAVIOR_FLAGS.length + 1) {
      // Update server.js
      const serverCode = getServerCode();
      if (serverCode) {
        const serverPath = target.entry.args?.[0] || path.join(INSTALL_DIR, "server.js");
        fs.writeFileSync(serverPath, serverCode);
        ok("server.js updated to latest version");
      } else {
        fail("Could not find server.js source");
      }
      continue;
    }
    if (num < 1 || num > BEHAVIOR_FLAGS.length) { warn("Invalid choice."); continue; }
    const flag = BEHAVIOR_FLAGS[num - 1];
    const current = env[flag.key] !== "false";
    env[flag.key] = current ? "false" : "true";
    changed = true;
    const newVal = !current;
    ok(`${flag.label}: ${newVal ? "ON" : "OFF"}`);
  }

  if (changed) {
    // Clean up: remove flags that are "true" (default) to keep config clean
    for (const flag of BEHAVIOR_FLAGS) {
      if (env[flag.key] === "true") delete env[flag.key];
    }
    target.entry.env = env;
    target.config[target.agent.key]["telegram-bridge"] = target.entry;
    // Backup
    const bak = target.configPath + ".bak." + Date.now();
    fs.copyFileSync(target.configPath, bak);
    info(`Backed up to ${path.basename(bak)}`);
    fs.writeFileSync(target.configPath, JSON.stringify(target.config, null, 2));
    ok(`Config saved to ${target.configPath}`);
    info("Restart your agent/IDE to apply changes.");
  } else {
    info("No changes made.");
  }

  console.log("");
  rl.close();
}

// ---------------------------------------------------------------------------
// Main installer
// ---------------------------------------------------------------------------
async function main() {
  // Route to configure if requested
  const args = process.argv.slice(2);
  if (args.includes("configure") || args.includes("--configure") || args.includes("-c")) {
    return runConfigure();
  }

  const TOTAL = 6;

  console.log("");
  console.log(`${C.cyan}${C.bold}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C.reset}`);
  console.log(`${C.cyan}${C.bold}â•‘       ğŸ“¡ Telegram MCP Bridge â€” Installer        â•‘${C.reset}`);
  console.log(`${C.cyan}${C.bold}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C.reset}`);
  console.log("");

  // â”€â”€ Step 1: Prerequisites â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  step(1, TOTAL, "Checking prerequisites");

  const nodeVersion = process.versions.node;
  const major = parseInt(nodeVersion.split(".")[0], 10);
  if (major < 18) {
    fail(`Node.js 18+ required (found v${nodeVersion})`);
    process.exit(1);
  }
  ok(`Node.js v${nodeVersion}`);

  // Check npm
  try {
    execSync("npm --version", { stdio: "pipe" });
    ok("npm available");
  } catch {
    fail("npm not found");
    process.exit(1);
  }

  // â”€â”€ Step 2: Choose agent â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  step(2, TOTAL, "Choose your AI agent / IDE");
  console.log("");
  for (const a of AGENTS) {
    console.log(`    ${C.bold}${a.id})${C.reset} ${a.name}`);
  }
  console.log("");

  let agentChoice;
  while (true) {
    const input = (await ask("Enter number [1-8]: ")).trim();
    const num = parseInt(input, 10);
    if (num >= 1 && num <= 8) { agentChoice = num; break; }
    warn("Invalid choice, try again.");
  }
  const agent = AGENTS.find((a) => a.id === agentChoice);
  ok(`Selected: ${agent.name}`);

  // â”€â”€ Step 3: Install npm dependencies â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  step(3, TOTAL, "Installing server & dependencies");

  fs.mkdirSync(INSTALL_DIR, { recursive: true });

  // Write package.json
  const pkg = {
    name: "telegram-mcp-bridge",
    version: "1.0.0",
    private: true,
    dependencies: {
      "@modelcontextprotocol/sdk": "^1.12.1",
    },
  };
  fs.writeFileSync(path.join(INSTALL_DIR, "package.json"), JSON.stringify(pkg, null, 2));

  // Deploy server.js (from adjacent file or embedded base64)
  const serverCode = getServerCode();
  if (!serverCode) {
    fail("server.js not found. If using the dev installer, place server.js next to install.js.");
    fail("If using the built installer, the base64 embedding is missing â€” re-run build.js.");
    process.exit(1);
  }
  fs.writeFileSync(path.join(INSTALL_DIR, "server.js"), serverCode);
  ok("Server deployed");

  // npm install
  info("Installing @modelcontextprotocol/sdk (this may take a moment)...");
  try {
    execSync("npm install --production", {
      cwd: INSTALL_DIR,
      stdio: "pipe",
      timeout: 120000,
    });
    ok("Dependencies installed");
  } catch (e) {
    fail("npm install failed: " + (e.stderr?.toString().slice(0, 200) || e.message));
    process.exit(1);
  }

  // â”€â”€ Step 4: Telegram bot setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  step(4, TOTAL, "Telegram Bot setup");
  console.log("");
  console.log(`  ${C.bold}Do you already have a Telegram bot token?${C.reset}`);
  console.log(`    ${C.bold}1)${C.reset} No, I need to create a new bot`);
  console.log(`    ${C.bold}2)${C.reset} Yes, I have a token ready`);
  console.log("");

  const hasToken = (await ask("Enter choice [1-2]: ")).trim();

  if (hasToken !== "2") {
    console.log("");
    console.log(`  ${C.bold}Opening BotFather in Telegram...${C.reset}`);
    info("If it doesn't open, go to: https://t.me/BotFather");
    console.log("");
    openUrl("https://t.me/BotFather");

    console.log(`  ${C.bold}In the BotFather chat:${C.reset}`);
    console.log("");
    console.log(`  ${C.cyan}1.${C.reset} Click ${C.bold}Start${C.reset} (or type /start)`);
    console.log(`  ${C.cyan}2.${C.reset} Type: ${C.bold}/newbot${C.reset}`);
    console.log(`  ${C.cyan}3.${C.reset} Enter any name, e.g.: ${C.bold}Agent Bridge${C.reset}`);
    console.log(`  ${C.cyan}4.${C.reset} Enter a username ending in 'bot', e.g.: ${C.bold}my_agent_bridge_bot${C.reset}`);
    console.log(`  ${C.cyan}5.${C.reset} BotFather gives you a token like: ${C.bold}7123456789:AAHfG3kB3x_example${C.reset}`);
    console.log("");
  }

  // --- Token input (robust: sanitize to avoid paste issues) ---
  console.log("");
  info("Tip: If pasting crashes, save the token to a file and enter the file path instead.");
  console.log("");
  const rawToken = (await ask("Paste your bot token (or path to a file containing it): ")).trim();

  let botToken;
  // Check if user gave a file path
  if (fs.existsSync(rawToken)) {
    botToken = fs.readFileSync(rawToken, "utf-8").trim();
    info("Read token from file");
  } else {
    botToken = rawToken;
  }
  // Sanitize: keep only valid token chars
  botToken = botToken.replace(/[^a-zA-Z0-9:_-]/g, "");

  if (!botToken) {
    fail("Token is empty. Please try again.");
    process.exit(1);
  }

  // Mask for display
  const masked = botToken.length > 10
    ? botToken.slice(0, 4) + "*".repeat(botToken.length - 8) + botToken.slice(-4)
    : botToken.slice(0, 2) + "****" + botToken.slice(-2);
  ok(`Token received: ${masked}`);

  if (!/^\d+:.+$/.test(botToken)) {
    warn("Token format looks unusual (expected 123456:ABC...). Continuing anyway.");
  }

  // --- Verify token ---
  info("Verifying bot token with Telegram...");
  let botUsername = "";
  try {
    const me = await tgApi(botToken, "getMe");
    if (me.ok) {
      const b = me.result;
      ok(`Bot verified: ${b.first_name} (@${b.username})`);
      botUsername = b.username;
    } else {
      warn("Token verification failed: " + JSON.stringify(me));
      const cont = (await ask("Continue anyway? [y/N]: ")).trim().toLowerCase();
      if (cont !== "y") process.exit(1);
    }
  } catch (e) {
    warn("Verification error: " + e.message);
    const cont = (await ask("Continue anyway? [y/N]: ")).trim().toLowerCase();
    if (cont !== "y") process.exit(1);
  }

  // --- Get chat ID (Forum Group setup) ---
  console.log("");
  console.log(`  ${C.bold}Now we need a Telegram group with Topics enabled.${C.reset}`);
  console.log(`  ${C.bold}Each agent session gets its own topic â€” full isolation.${C.reset}`);
  console.log("");
  console.log(`  ${C.bold}Do you already have a forum group set up?${C.reset}`);
  console.log(`    ${C.bold}1)${C.reset} No, help me create one`);
  console.log(`    ${C.bold}2)${C.reset} Yes, I have the group Chat ID ready`);
  console.log("");

  const hasGroup = (await ask("Enter choice [1-2]: ")).trim();

  if (hasGroup !== "2") {
    console.log("");
    console.log(`  ${C.cyan}${C.bold}Follow these steps in Telegram:${C.reset}`);
    console.log("");
    console.log(`  ${C.cyan}1.${C.reset} Open Telegram and tap ${C.bold}New Group${C.reset}`);
    console.log(`  ${C.cyan}2.${C.reset} Add your bot ${C.bold}@${botUsername || "your_bot"}${C.reset} as a member`);
    console.log(`  ${C.cyan}3.${C.reset} Name it something like ${C.bold}Agent Bridge${C.reset} and create it`);
    console.log(`  ${C.cyan}4.${C.reset} Open ${C.bold}Group Settings${C.reset} (tap group name at top)`);
    console.log(`  ${C.cyan}5.${C.reset} Tap ${C.bold}Edit${C.reset} (pencil icon) â†’ scroll down`);
    console.log(`  ${C.cyan}6.${C.reset} Enable ${C.bold}Topics${C.reset} (this converts it to a forum supergroup)`);
    console.log(`  ${C.cyan}7.${C.reset} Go to ${C.bold}Administrators${C.reset} â†’ tap your bot â†’ enable:`);
    console.log(`     â€¢ ${C.bold}Manage Topics${C.reset}`);
    console.log(`     â€¢ ${C.bold}Delete Messages${C.reset} (optional but recommended)`);
    console.log(`  ${C.cyan}8.${C.reset} Send any message in the group (e.g. ${C.bold}hello${C.reset})`);
    console.log("");
    info("The installer will detect the group automatically...");
    console.log("");
  }

  // Flush old updates and track offset
  let detectOffset = 0;
  try {
    const old = await tgApi(botToken, "getUpdates", { offset: -1 });
    if (old.ok && old.result && old.result.length) {
      detectOffset = old.result[old.result.length - 1].update_id + 1;
      await tgApi(botToken, "getUpdates", { offset: detectOffset });
    }
  } catch { /* ignore */ }

  let chatId = "";
  let chatTitle = "";

  if (hasGroup === "2") {
    chatId = (await ask("Enter your group Chat ID (starts with -): ")).trim();
  } else {
    // Poll for new message from the group
    const pollStart = Date.now();
    const pollTimeout = 180000; // 3 minutes

    process.stdout.write(`  ${C.cyan}â³${C.reset} ${C.dim}Waiting for a message in the group...${C.reset}`);

    while (Date.now() - pollStart < pollTimeout) {
      try {
        const res = await tgApi(botToken, "getUpdates", { offset: detectOffset, timeout: 5 });
        if (res.ok && res.result) {
          for (const u of res.result) {
            detectOffset = u.update_id + 1;
            const msg = u.message;
            if (!msg || !msg.chat) continue;
            // Look for supergroup (forum groups are supergroups)
            if (msg.chat.type === "supergroup" || msg.chat.type === "group") {
              chatId = String(msg.chat.id);
              chatTitle = msg.chat.title || "";
              await tgApi(botToken, "getUpdates", { offset: detectOffset });
              break;
            }
          }
        }
        if (chatId) break;
      } catch { /* retry */ }
      process.stdout.write(".");
      await new Promise((r) => setTimeout(r, 2000));
    }
    console.log(""); // newline after dots

    if (!chatId) {
      warn("Auto-detect timed out.");
      console.log("");
      info("Find it manually: open this URL in a browser:");
      info(`https://api.telegram.org/bot${botToken}/getUpdates`);
      info('Look for: "chat":{"id":-100XXXXXXXXXX,"type":"supergroup"}');
      console.log("");
      chatId = (await ask("Enter your group Chat ID: ")).trim();
    }
  }

  if (chatId) {
    ok(`Detected! Chat ID: ${chatId}${chatTitle ? ` (${chatTitle})` : ""}`);
  }

  if (!chatId || !/^-?\d+$/.test(chatId)) {
    fail("Invalid chat ID. Group IDs typically start with -100...");
    process.exit(1);
  }

  // --- Verify it's a forum group (handle migration) ---
  info("Verifying group setup...");
  let isForumGroup = false;
  try {
    let chatInfo = await tgApi(botToken, "getChat", { chat_id: parseInt(chatId, 10) });

    // Handle migration: old group â†’ supergroup
    if (!chatInfo.ok && chatInfo.parameters?.migrate_to_chat_id) {
      const newId = String(chatInfo.parameters.migrate_to_chat_id);
      info(`Group migrated to supergroup: ${chatId} â†’ ${newId}`);
      chatId = newId;
      chatInfo = await tgApi(botToken, "getChat", { chat_id: parseInt(chatId, 10) });
    }

    if (chatInfo.ok && chatInfo.result) {
      const chat = chatInfo.result;
      // Also handle migration via response (some API versions return it differently)
      if (chat.id && String(chat.id) !== chatId) {
        info(`Chat ID updated: ${chatId} â†’ ${chat.id}`);
        chatId = String(chat.id);
      }
      if (chat.is_forum) {
        ok("Forum topics are enabled âœ“");
        isForumGroup = true;
      } else {
        warn("Topics are NOT enabled on this group.");
        console.log("");
        console.log(`  ${C.bold}To enable Topics:${C.reset}`);
        console.log(`  1. Open the group in Telegram`);
        console.log(`  2. Tap the group name â†’ Edit â†’ enable Topics`);
        console.log("");
        const cont = (await ask("Continue anyway? [y/N]: ")).trim().toLowerCase();
        if (cont !== "y") process.exit(1);
      }
    }
  } catch (e) {
    warn("Could not verify group: " + e.message);
  }

  // --- Verify bot is admin with manage_topics ---
  try {
    const me = await tgApi(botToken, "getMe");
    if (me.ok) {
      const member = await tgApi(botToken, "getChatMember", {
        chat_id: parseInt(chatId, 10),
        user_id: me.result.id,
      });
      if (member.ok && member.result) {
        const status = member.result.status;
        if (status === "administrator" || status === "creator") {
          const canManageTopics = member.result.can_manage_topics;
          if (canManageTopics) {
            ok("Bot is admin with Manage Topics permission âœ“");
          } else {
            warn("Bot is admin but missing 'Manage Topics' permission.");
            info("Go to Group Settings â†’ Administrators â†’ your bot â†’ enable Manage Topics");
          }
        } else {
          warn("Bot is not an administrator in this group.");
          info("Go to Group Settings â†’ Administrators â†’ Add your bot as admin");
          info("Enable at least: Manage Topics");
        }
      }
    }
  } catch (e) {
    warn("Could not check bot permissions: " + e.message);
  }

  // --- Send test message ---
  info("Sending test message...");
  try {
    const testRes = await tgApi(botToken, "sendMessage", {
      chat_id: parseInt(chatId, 10),
      text: "ğŸ”— *Telegram MCP Bridge installed!*\n\nEach agent session will create its own topic here.\nChat ID: `" + chatId + "`",
      parse_mode: "Markdown",
    });
    if (testRes.ok) ok("Test message sent â€” check your Telegram group!");
    else warn("Test message failed, continuing.");
  } catch {
    try {
      await tgApi(botToken, "sendMessage", {
        chat_id: parseInt(chatId, 10),
        text: "Telegram MCP Bridge installed! Each agent session will create its own topic here. Chat ID: " + chatId,
      });
      ok("Test message sent (plain text)");
    } catch {
      warn("Test message failed. Make sure the bot is in the group and is an admin.");
    }
  }

  // â”€â”€ Step 5: Write agent prompt â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  step(5, TOTAL, "Writing agent instructions");

  const agentPrompt = `# Telegram Bridge â€” Agent Instructions

You have access to a Telegram MCP bridge for async communication with the user.
Each session has its own topic in a Telegram forum group â€” your messages are isolated.

## Tool: \`interact\`
Single unified tool for all communication:
- \`interact({message: "text"})\` â€” Send a message
- \`interact({})\` â€” Check for new messages
- \`interact({wait: 120})\` â€” Wait up to 120s for a reply
- \`interact({message: "text", wait: 60, since_ts: N})\` â€” Send + wait + filter stale

Response: \`{ok, sent?, messages: [{text, ts}], pending, now}\`
Pass \`now\` as \`since_ts\` on next call to only get newer messages.

## Protocol
1. **Start**: \`interact\` with a greeting and plan summary.
2. **During work**: \`interact\` periodically (every few minutes) to check for input.
3. **Need input**: \`interact\` with your question + \`wait: 120\`.
4. **Done**: \`interact\` with a final summary + \`wait: 120\`.

## Tips
- Keep messages concise (phone-readable).
- Use \`since_ts\` to avoid reading stale messages from before your question.
- Batch updates â€” don't spam multiple messages.
`;
  fs.writeFileSync(path.join(INSTALL_DIR, "AGENT_PROMPT.md"), agentPrompt);
  ok(`Agent prompt saved to ${path.join(INSTALL_DIR, "AGENT_PROMPT.md")}`);

  // Write uninstall script
  if (IS_WIN) {
    fs.writeFileSync(path.join(INSTALL_DIR, "uninstall.bat"),
      `@echo off\r\necho Removing Telegram MCP Bridge...\r\nrd /s /q "%USERPROFILE%\\.telegram-mcp-bridge"\r\ndel /f "%USERPROFILE%\\.telegram_mcp_queue.json" 2>nul\r\necho Done! Remember to remove "telegram-bridge" from your agent's MCP config.\r\npause\r\n`
    );
  } else {
    fs.writeFileSync(path.join(INSTALL_DIR, "uninstall.sh"),
      `#!/bin/bash\necho "Removing Telegram MCP Bridge..."\nrm -rf "${os.homedir()}/.telegram-mcp-bridge"\nrm -f "${os.homedir()}/.telegram_mcp_queue.json"\necho "Done! Remember to remove \\"telegram-bridge\\" from your agent's MCP config."\n`
    );
    try { fs.chmodSync(path.join(INSTALL_DIR, "uninstall.sh"), 0o755); } catch { /* ok */ }
  }

  // â”€â”€ Step 6: Configure agent â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  step(6, TOTAL, `Configuring ${agent.name}`);

  const serverPath = path.join(INSTALL_DIR, "server.js");
  const entry = makeServerEntry(serverPath, botToken, chatId);
  const configPath = agent.configPath();

  if (configPath === "__vscode__") {
    console.log("");
    console.log(`  ${C.yellow}VS Code uses workspace-level MCP config.${C.reset}`);
    console.log(`  Create ${C.bold}.vscode/mcp.json${C.reset} in your project with:`);
    console.log("");
    console.log(JSON.stringify({ servers: { "telegram-bridge": { type: "stdio", ...entry } } }, null, 2)
      .split("\n").map((l) => "  " + l).join("\n"));
    console.log("");
    ok("Copy the JSON above into .vscode/mcp.json");
  } else if (configPath === "__manual__") {
    console.log("");
    console.log(`  ${C.bold}Add this to your agent's MCP config:${C.reset}`);
    console.log("");
    console.log(JSON.stringify({ "telegram-bridge": entry }, null, 2)
      .split("\n").map((l) => "  " + l).join("\n"));
    console.log("");
    ok("Copy the JSON above into your config");
  } else {
    try {
      injectConfig(configPath, agent.key, entry);
      ok(`Config written to ${configPath}`);
    } catch (e) {
      fail(`Auto-config failed: ${e.message}`);
      console.log("");
      console.log(`  ${C.bold}Add this manually to ${configPath}:${C.reset}`);
      console.log(JSON.stringify({ "telegram-bridge": entry }, null, 2)
        .split("\n").map((l) => "  " + l).join("\n"));
    }
  }

  // â”€â”€ Done! â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  console.log("");
  console.log(`${C.green}${C.bold}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${C.reset}`);
  console.log(`${C.green}${C.bold}â•‘           âœ… Installation complete!              â•‘${C.reset}`);
  console.log(`${C.green}${C.bold}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${C.reset}`);
  console.log("");
  console.log(`  ${C.bold}Server:${C.reset}       ${serverPath}`);
  console.log(`  ${C.bold}Agent:${C.reset}        ${agent.name}`);
  if (configPath !== "__vscode__" && configPath !== "__manual__") {
    console.log(`  ${C.bold}Config:${C.reset}       ${configPath}`);
  }
  console.log(`  ${C.bold}Bot:${C.reset}          @${botUsername || "unknown"}`);
  console.log(`  ${C.bold}Chat ID:${C.reset}      ${chatId}`);
  console.log(`  ${C.bold}Mode:${C.reset}         Forum Topics (per-session isolation)`);
  console.log("");
  console.log(`  ${C.bold}Next steps:${C.reset}`);
  info("1. Restart your agent / IDE to load the new MCP server");
  info(`2. Add the contents of ${path.join(INSTALL_DIR, "AGENT_PROMPT.md")}`);
  info("   to your system prompt (CLAUDE.md / GEMINI.md / .cursorrules / rules)");
  info("3. Ask your agent to send you a Telegram message!");
  info("   â†’ It will auto-create a topic in your forum group");
  console.log("");
  if (IS_WIN) {
    console.log(`  ${C.bold}Uninstall:${C.reset}  ${C.dim}${path.join(INSTALL_DIR, "uninstall.bat")}${C.reset}`);
  } else {
    console.log(`  ${C.bold}Uninstall:${C.reset}  ${C.dim}${path.join(INSTALL_DIR, "uninstall.sh")}${C.reset}`);
  }
  console.log("");

  rl.close();
}

main().catch((e) => {
  console.error(`\n${C.red}Fatal error:${C.reset} ${e.message}`);
  process.exit(1);
});
